// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../../../react
//   ../../../../../@blueprintjs/icons
//   ../../../../../popper.js
//   ../../../../../prop-types

declare module '@blueprintjs/core' {
    export * from "@blueprintjs/core/accessibility";
    export * from "@blueprintjs/core/common";
    export * from "@blueprintjs/core/components";
}

declare module '@blueprintjs/core/accessibility' {
    export * from "@blueprintjs/core/accessibility/focusStyleManager";
}

declare module '@blueprintjs/core/common' {
    export * from "@blueprintjs/core/common/abstractComponent";
    export * from "@blueprintjs/core/common/abstractPureComponent";
    export * from "@blueprintjs/core/common/alignment";
    export * from "@blueprintjs/core/common/boundary";
    export * from "@blueprintjs/core/common/colors";
    export * from "@blueprintjs/core/common/constructor";
    export * from "@blueprintjs/core/common/elevation";
    export * from "@blueprintjs/core/common/intent";
    export * from "@blueprintjs/core/common/position";
    export * from "@blueprintjs/core/common/props";
    import * as Classes from "@blueprintjs/core/common/classes";
    import * as Keys from "@blueprintjs/core/common/keys";
    import * as Utils from "@blueprintjs/core/common/utils";
    export { Classes, Keys, Utils };
}

declare module '@blueprintjs/core/components' {
    import * as contextMenu from "@blueprintjs/core/components/context-menu/contextMenu";
    export const ContextMenu: typeof contextMenu;
    export * from "@blueprintjs/core/components/alert/alert";
    export * from "@blueprintjs/core/components/breadcrumbs/breadcrumb";
    export * from "@blueprintjs/core/components/breadcrumbs/breadcrumbs";
    export * from "@blueprintjs/core/components/button/buttons";
    export * from "@blueprintjs/core/components/button/buttonGroup";
    export * from "@blueprintjs/core/components/callout/callout";
    export * from "@blueprintjs/core/components/card/card";
    export * from "@blueprintjs/core/components/collapse/collapse";
    export * from "@blueprintjs/core/components/collapsible-list/collapsibleList";
    export * from "@blueprintjs/core/components/context-menu/contextMenuTarget";
    export * from "@blueprintjs/core/components/dialog/dialog";
    export * from "@blueprintjs/core/components/divider/divider";
    export * from "@blueprintjs/core/components/drawer/drawer";
    export * from "@blueprintjs/core/components/editable-text/editableText";
    export * from "@blueprintjs/core/components/forms/controlGroup";
    export * from "@blueprintjs/core/components/forms/controls";
    export * from "@blueprintjs/core/components/forms/fileInput";
    export * from "@blueprintjs/core/components/forms/formGroup";
    export * from "@blueprintjs/core/components/forms/inputGroup";
    export * from "@blueprintjs/core/components/forms/numericInput";
    export * from "@blueprintjs/core/components/forms/radioGroup";
    export * from "@blueprintjs/core/components/forms/textArea";
    export * from "@blueprintjs/core/components/html/html";
    export * from "@blueprintjs/core/components/html-select/htmlSelect";
    export * from "@blueprintjs/core/components/html-table/htmlTable";
    export * from "@blueprintjs/core/components/hotkeys/hotkeys";
    export * from "@blueprintjs/core/components/icon/icon";
    export * from "@blueprintjs/core/components/menu/menu";
    export * from "@blueprintjs/core/components/menu/menuDivider";
    export * from "@blueprintjs/core/components/menu/menuItem";
    export * from "@blueprintjs/core/components/navbar/navbar";
    export * from "@blueprintjs/core/components/navbar/navbarDivider";
    export * from "@blueprintjs/core/components/navbar/navbarGroup";
    export * from "@blueprintjs/core/components/navbar/navbarHeading";
    export * from "@blueprintjs/core/components/non-ideal-state/nonIdealState";
    export * from "@blueprintjs/core/components/overflow-list/overflowList";
    export * from "@blueprintjs/core/components/overlay/overlay";
    export * from "@blueprintjs/core/components/text/text";
    export * from "@blueprintjs/core/components/panel-stack/panelProps";
    export * from "@blueprintjs/core/components/panel-stack/panelStack";
    export * from "@blueprintjs/core/components/popover/popover";
    export * from "@blueprintjs/core/components/popover/popoverSharedProps";
    export * from "@blueprintjs/core/components/portal/portal";
    export * from "@blueprintjs/core/components/progress-bar/progressBar";
    export * from "@blueprintjs/core/components/resize-sensor/resizeSensor";
    export * from "@blueprintjs/core/components/slider/handleProps";
    export * from "@blueprintjs/core/components/slider/multiSlider";
    export * from "@blueprintjs/core/components/slider/rangeSlider";
    export * from "@blueprintjs/core/components/slider/slider";
    export * from "@blueprintjs/core/components/spinner/spinner";
    export * from "@blueprintjs/core/components/tabs/tab";
    export * from "@blueprintjs/core/components/tabs/tabs";
    export * from "@blueprintjs/core/components/tag/tag";
    export * from "@blueprintjs/core/components/tag-input/tagInput";
    export * from "@blueprintjs/core/components/toast/toast";
    export * from "@blueprintjs/core/components/toast/toaster";
    export * from "@blueprintjs/core/components/tooltip/tooltip";
    export * from "@blueprintjs/core/components/tree/tree";
    export * from "@blueprintjs/core/components/tree/treeNode";
}

declare module '@blueprintjs/core/accessibility/focusStyleManager' {
    export const FocusStyleManager: {
        alwaysShowFocus: () => boolean | void;
        isActive: () => boolean;
        onlyShowFocusOnTabs: () => boolean | void;
    };
}

declare module '@blueprintjs/core/common/abstractComponent' {
    import * as React from "react";
    /**
        * An abstract component that Blueprint components can extend
        * in order to add some common functionality like runtime props validation.
        */
    export abstract class AbstractComponent<P, S> extends React.Component<P, S> {
            /** Component displayName should be `public static`. This property exists to prevent incorrect usage. */
            protected displayName: never;
            constructor(props?: P, context?: any);
            componentWillReceiveProps(nextProps: P & {
                    children?: React.ReactNode;
            }): void;
            componentWillUnmount(): void;
            /**
                * Set a timeout and remember its ID.
                * All stored timeouts will be cleared when component unmounts.
                * @returns a "cancel" function that will clear timeout when invoked.
                */
            setTimeout(callback: () => void, timeout?: number): () => void;
            /**
                * Clear all known timeouts.
                */
            clearTimeouts: () => void;
            /**
                * Ensures that the props specified for a component are valid.
                * Implementations should check that props are valid and usually throw an Error if they are not.
                * Implementations should not duplicate checks that the type system already guarantees.
                *
                * This method should be used instead of React's
                * [propTypes](https://facebook.github.io/react/docs/reusable-components.html#prop-validation) feature.
                * Like propTypes, these runtime checks run only in development mode.
                */
            protected validateProps(_: P & {
                    children?: React.ReactNode;
            }): void;
    }
}

declare module '@blueprintjs/core/common/abstractPureComponent' {
    import * as React from "react";
    /**
        * An abstract component that Blueprint components can extend
        * in order to add some common functionality like runtime props validation.
        */
    export abstract class AbstractPureComponent<P, S = {}> extends React.PureComponent<P, S> {
            /** Component displayName should be `public static`. This property exists to prevent incorrect usage. */
            protected displayName: never;
            constructor(props?: P, context?: any);
            componentWillReceiveProps(nextProps: P & {
                    children?: React.ReactNode;
            }): void;
            componentWillUnmount(): void;
            /**
                * Set a timeout and remember its ID.
                * All stored timeouts will be cleared when component unmounts.
                * @returns a "cancel" function that will clear timeout when invoked.
                */
            setTimeout(callback: () => void, timeout?: number): () => void;
            /**
                * Clear all known timeouts.
                */
            clearTimeouts: () => void;
            /**
                * Ensures that the props specified for a component are valid.
                * Implementations should check that props are valid and usually throw an Error if they are not.
                * Implementations should not duplicate checks that the type system already guarantees.
                *
                * This method should be used instead of React's
                * [propTypes](https://facebook.github.io/react/docs/reusable-components.html#prop-validation) feature.
                * Like propTypes, these runtime checks run only in development mode.
                */
            protected validateProps(_: P & {
                    children?: React.ReactNode;
            }): void;
    }
}

declare module '@blueprintjs/core/common/alignment' {
    /** Alignment along the horizontal axis. */
    export const Alignment: {
        CENTER: "center";
        LEFT: "left";
        RIGHT: "right";
    };
    export type Alignment = typeof Alignment[keyof typeof Alignment];
}

declare module '@blueprintjs/core/common/boundary' {
    /** Boundary of a one-dimensional interval. */
    export const Boundary: {
        START: "start";
        END: "end";
    };
    export type Boundary = typeof Boundary[keyof typeof Boundary];
}

declare module '@blueprintjs/core/common/colors' {
    export const Colors: {
        BLACK: string;
        BLUE1: string;
        BLUE2: string;
        BLUE3: string;
        BLUE4: string;
        BLUE5: string;
        COBALT1: string;
        COBALT2: string;
        COBALT3: string;
        COBALT4: string;
        COBALT5: string;
        DARK_GRAY1: string;
        DARK_GRAY2: string;
        DARK_GRAY3: string;
        DARK_GRAY4: string;
        DARK_GRAY5: string;
        FOREST1: string;
        FOREST2: string;
        FOREST3: string;
        FOREST4: string;
        FOREST5: string;
        GOLD1: string;
        GOLD2: string;
        GOLD3: string;
        GOLD4: string;
        GOLD5: string;
        GRAY1: string;
        GRAY2: string;
        GRAY3: string;
        GRAY4: string;
        GRAY5: string;
        GREEN1: string;
        GREEN2: string;
        GREEN3: string;
        GREEN4: string;
        GREEN5: string;
        INDIGO1: string;
        INDIGO2: string;
        INDIGO3: string;
        INDIGO4: string;
        INDIGO5: string;
        LIGHT_GRAY1: string;
        LIGHT_GRAY2: string;
        LIGHT_GRAY3: string;
        LIGHT_GRAY4: string;
        LIGHT_GRAY5: string;
        LIME1: string;
        LIME2: string;
        LIME3: string;
        LIME4: string;
        LIME5: string;
        ORANGE1: string;
        ORANGE2: string;
        ORANGE3: string;
        ORANGE4: string;
        ORANGE5: string;
        RED1: string;
        RED2: string;
        RED3: string;
        RED4: string;
        RED5: string;
        ROSE1: string;
        ROSE2: string;
        ROSE3: string;
        ROSE4: string;
        ROSE5: string;
        SEPIA1: string;
        SEPIA2: string;
        SEPIA3: string;
        SEPIA4: string;
        SEPIA5: string;
        TURQUOISE1: string;
        TURQUOISE2: string;
        TURQUOISE3: string;
        TURQUOISE4: string;
        TURQUOISE5: string;
        VERMILION1: string;
        VERMILION2: string;
        VERMILION3: string;
        VERMILION4: string;
        VERMILION5: string;
        VIOLET1: string;
        VIOLET2: string;
        VIOLET3: string;
        VIOLET4: string;
        VIOLET5: string;
        WHITE: string;
    };
}

declare module '@blueprintjs/core/common/constructor' {
    /**
      * Generic interface defining constructor types, such as classes. This is used to type the class
      * itself in meta-programming situations such as decorators.
      */
    export interface IConstructor<T> {
        new (...args: any[]): T;
    }
}

declare module '@blueprintjs/core/common/elevation' {
    export const Elevation: {
        ZERO: 0;
        ONE: 1;
        TWO: 2;
        THREE: 3;
        FOUR: 4;
    };
    export type Elevation = typeof Elevation[keyof typeof Elevation];
}

declare module '@blueprintjs/core/common/intent' {
    /**
      * The four basic intents.
      */
    export const Intent: {
        NONE: "none";
        PRIMARY: "primary";
        SUCCESS: "success";
        WARNING: "warning";
        DANGER: "danger";
    };
    export type Intent = typeof Intent[keyof typeof Intent];
}

declare module '@blueprintjs/core/common/position' {
    export const Position: {
        BOTTOM: "bottom";
        BOTTOM_LEFT: "bottom-left";
        BOTTOM_RIGHT: "bottom-right";
        LEFT: "left";
        LEFT_BOTTOM: "left-bottom";
        LEFT_TOP: "left-top";
        RIGHT: "right";
        RIGHT_BOTTOM: "right-bottom";
        RIGHT_TOP: "right-top";
        TOP: "top";
        TOP_LEFT: "top-left";
        TOP_RIGHT: "top-right";
    };
    export type Position = typeof Position[keyof typeof Position];
    export function isPositionHorizontal(position: Position): boolean;
    export function isPositionVertical(position: Position): boolean;
    export function getPositionIgnoreAngles(position: Position): "left" | "right" | "bottom" | "top";
}

declare module '@blueprintjs/core/common/props' {
    import * as React from "react";
    import { IconName } from "@blueprintjs/icons";
    import { Intent } from "@blueprintjs/core/common/intent";
    export const DISPLAYNAME_PREFIX = "Blueprint3";
    /**
        * Alias for all valid HTML props for `<div>` element.
        * Does not include React's `ref` or `key`.
        */
    export type HTMLDivProps = React.HTMLAttributes<HTMLDivElement>;
    /**
        * Alias for all valid HTML props for `<input>` element.
        * Does not include React's `ref` or `key`.
        */
    export type HTMLInputProps = React.InputHTMLAttributes<HTMLInputElement>;
    /**
        * Alias for a `JSX.Element` or a value that renders nothing.
        *
        * In React, `boolean`, `null`, and `undefined` do not produce any output.
        */
    export type MaybeElement = JSX.Element | false | null | undefined;
    /**
        * A shared base interface for all Blueprint component props.
        */
    export interface IProps {
            /** A space-delimited list of class names to pass along to a child element. */
            className?: string;
    }
    export interface IIntentProps {
            /** Visual intent color to apply to element. */
            intent?: Intent;
    }
    /**
        * Interface for a clickable action, such as a button or menu item.
        * These props can be spready directly to a `<Button>` or `<MenuItem>` element.
        */
    export interface IActionProps extends IIntentProps, IProps {
            /** Whether this action is non-interactive. */
            disabled?: boolean;
            /** Name of a Blueprint UI icon (or an icon element) to render before the text. */
            icon?: IconName | MaybeElement;
            /** Click event handler. */
            onClick?: (event: React.MouseEvent<HTMLElement>) => void;
            /** Action text. Can be any single React renderable. */
            text?: React.ReactNode;
    }
    /** Interface for a link, with support for customizing target window. */
    export interface ILinkProps {
            /** Link URL. */
            href?: string;
            /** Link target attribute. Use `"_blank"` to open in a new window. */
            target?: string;
    }
    /** Interface for a controlled input. */
    export interface IControlledProps {
            /** Initial value of the input, for uncontrolled usage. */
            defaultValue?: string;
            /** Change event handler. Use `event.target.value` for new value. */
            onChange?: React.FormEventHandler<HTMLElement>;
            /** Form value of the input, for controlled usage. */
            value?: string;
    }
    /**
        * An interface for an option in a list, such as in a `<select>` or `RadioGroup`.
        * These props can be spread directly to an `<option>` or `<Radio>` element.
        */
    export interface IOptionProps extends IProps {
            /** Whether this option is non-interactive. */
            disabled?: boolean;
            /** Label text for this option. If omitted, `value` is used as the label. */
            label?: string;
            /** Value of this option. */
            value: string | number;
    }
    /**
        * Typically applied to HTMLElements to filter out blacklisted props. When applied to a Component,
        * can filter props from being passed down to the children. Can also filter by a combined list of
        * supplied prop keys and the blacklist (only appropriate for HTMLElements).
        * @param props The original props object to filter down.
        * @param {string[]} invalidProps If supplied, overwrites the default blacklist.
        * @param {boolean} shouldMerge If true, will merge supplied invalidProps and blacklist together.
        */
    export function removeNonHTMLProps(props: {
            [key: string]: any;
    }, invalidProps?: string[], shouldMerge?: boolean): {
            [key: string]: any;
    };
}

declare module '@blueprintjs/core/common/classes' {
    import { Alignment } from "@blueprintjs/core/common/alignment";
    import { Elevation } from "@blueprintjs/core/common/elevation";
    import { Intent } from "@blueprintjs/core/common/intent";
    import { Position } from "@blueprintjs/core/common/position";
    export const ACTIVE: string;
    export const ALIGN_LEFT: string;
    export const ALIGN_RIGHT: string;
    export const DARK: string;
    export const DISABLED: string;
    export const FILL: string;
    export const FIXED: string;
    export const FIXED_TOP: string;
    export const INLINE: string;
    export const INTERACTIVE: string;
    export const LARGE: string;
    export const LOADING: string;
    export const MINIMAL: string;
    export const MULTILINE: string;
    export const ROUND: string;
    export const SMALL: string;
    export const VERTICAL: string;
    export const POSITION_TOP: string;
    export const POSITION_BOTTOM: string;
    export const POSITION_LEFT: string;
    export const POSITION_RIGHT: string;
    export const ELEVATION_0: string;
    export const ELEVATION_1: string;
    export const ELEVATION_2: string;
    export const ELEVATION_3: string;
    export const ELEVATION_4: string;
    export const INTENT_PRIMARY: string;
    export const INTENT_SUCCESS: string;
    export const INTENT_WARNING: string;
    export const INTENT_DANGER: string;
    export const FOCUS_DISABLED: string;
    export const UI_TEXT: string;
    export const RUNNING_TEXT: string;
    export const MONOSPACE_TEXT: string;
    export const TEXT_LARGE: string;
    export const TEXT_SMALL: string;
    export const TEXT_MUTED: string;
    export const TEXT_DISABLED: string;
    export const TEXT_OVERFLOW_ELLIPSIS: string;
    export const BLOCKQUOTE: string;
    export const CODE: string;
    export const CODE_BLOCK: string;
    export const HEADING: string;
    export const LIST: string;
    export const LIST_UNSTYLED: string;
    export const RTL: string;
    export const ALERT: string;
    export const ALERT_BODY: string;
    export const ALERT_CONTENTS: string;
    export const ALERT_FOOTER: string;
    export const BREADCRUMB: string;
    export const BREADCRUMB_CURRENT: string;
    export const BREADCRUMBS: string;
    export const BREADCRUMBS_COLLAPSED: string;
    export const BUTTON: string;
    export const BUTTON_GROUP: string;
    export const BUTTON_SPINNER: string;
    export const BUTTON_TEXT: string;
    export const CALLOUT: string;
    export const CALLOUT_ICON: string;
    export const CARD: string;
    export const COLLAPSE: string;
    export const COLLAPSE_BODY: string;
    export const COLLAPSIBLE_LIST: string;
    export const CONTEXT_MENU: string;
    export const CONTEXT_MENU_POPOVER_TARGET: string;
    export const CONTROL_GROUP: string;
    export const DIALOG: string;
    export const DIALOG_CONTAINER: string;
    export const DIALOG_BODY: string;
    export const DIALOG_CLOSE_BUTTON: string;
    export const DIALOG_FOOTER: string;
    export const DIALOG_FOOTER_ACTIONS: string;
    export const DIALOG_HEADER: string;
    export const DIVIDER: string;
    export const DRAWER: string;
    export const DRAWER_BODY: string;
    export const DRAWER_FOOTER: string;
    export const DRAWER_HEADER: string;
    export const EDITABLE_TEXT: string;
    export const EDITABLE_TEXT_CONTENT: string;
    export const EDITABLE_TEXT_EDITING: string;
    export const EDITABLE_TEXT_INPUT: string;
    export const EDITABLE_TEXT_PLACEHOLDER: string;
    export const FLEX_EXPANDER: string;
    export const HTML_SELECT: string;
    /** @deprecated prefer `<HTMLSelect>` component */
    export const SELECT: string;
    export const HTML_TABLE: string;
    export const HTML_TABLE_BORDERED: string;
    export const HTML_TABLE_CONDENSED: string;
    export const HTML_TABLE_STRIPED: string;
    export const INPUT: string;
    export const INPUT_GHOST: string;
    export const INPUT_GROUP: string;
    export const INPUT_ACTION: string;
    export const CONTROL: string;
    export const CONTROL_INDICATOR: string;
    export const CONTROL_INDICATOR_CHILD: string;
    export const CHECKBOX: string;
    export const RADIO: string;
    export const SWITCH: string;
    export const SWITCH_INNER_TEXT: string;
    export const FILE_INPUT: string;
    export const FILE_INPUT_HAS_SELECTION: string;
    export const FILE_UPLOAD_INPUT: string;
    export const KEY: string;
    export const KEY_COMBO: string;
    export const MODIFIER_KEY: string;
    export const HOTKEY: string;
    export const HOTKEY_LABEL: string;
    export const HOTKEY_COLUMN: string;
    export const HOTKEY_DIALOG: string;
    export const LABEL: string;
    export const FORM_GROUP: string;
    export const FORM_CONTENT: string;
    export const FORM_HELPER_TEXT: string;
    export const MENU: string;
    export const MENU_ITEM: string;
    export const MENU_ITEM_LABEL: string;
    export const MENU_SUBMENU: string;
    export const MENU_DIVIDER: string;
    export const MENU_HEADER: string;
    export const NAVBAR: string;
    export const NAVBAR_GROUP: string;
    export const NAVBAR_HEADING: string;
    export const NAVBAR_DIVIDER: string;
    export const NON_IDEAL_STATE: string;
    export const NON_IDEAL_STATE_VISUAL: string;
    export const NUMERIC_INPUT: string;
    export const OVERFLOW_LIST: string;
    export const OVERFLOW_LIST_SPACER: string;
    export const OVERLAY: string;
    export const OVERLAY_BACKDROP: string;
    export const OVERLAY_CONTAINER: string;
    export const OVERLAY_CONTENT: string;
    export const OVERLAY_INLINE: string;
    export const OVERLAY_OPEN: string;
    export const OVERLAY_SCROLL_CONTAINER: string;
    export const PANEL_STACK: string;
    export const PANEL_STACK_HEADER: string;
    export const PANEL_STACK_HEADER_BACK: string;
    export const PANEL_STACK_VIEW: string;
    export const POPOVER: string;
    export const POPOVER_ARROW: string;
    export const POPOVER_BACKDROP: string;
    export const POPOVER_CONTENT: string;
    export const POPOVER_CONTENT_SIZING: string;
    export const POPOVER_DISMISS: string;
    export const POPOVER_DISMISS_OVERRIDE: string;
    export const POPOVER_OPEN: string;
    export const POPOVER_TARGET: string;
    export const POPOVER_WRAPPER: string;
    export const TRANSITION_CONTAINER: string;
    export const PROGRESS_BAR: string;
    export const PROGRESS_METER: string;
    export const PROGRESS_NO_STRIPES: string;
    export const PROGRESS_NO_ANIMATION: string;
    export const PORTAL: string;
    export const SKELETON: string;
    export const SLIDER: string;
    export const SLIDER_AXIS: string;
    export const SLIDER_HANDLE: string;
    export const SLIDER_LABEL: string;
    export const SLIDER_TRACK: string;
    export const SLIDER_PROGRESS: string;
    export const START: string;
    export const END: string;
    export const SPINNER: string;
    export const SPINNER_ANIMATION: string;
    export const SPINNER_HEAD: string;
    export const SPINNER_NO_SPIN: string;
    export const SPINNER_TRACK: string;
    export const TAB: string;
    export const TAB_INDICATOR: string;
    export const TAB_INDICATOR_WRAPPER: string;
    export const TAB_LIST: string;
    export const TAB_PANEL: string;
    export const TABS: string;
    export const TAG: string;
    export const TAG_REMOVE: string;
    export const TAG_INPUT: string;
    export const TAG_INPUT_ICON: string;
    export const TAG_INPUT_VALUES: string;
    export const TOAST: string;
    export const TOAST_CONTAINER: string;
    export const TOAST_MESSAGE: string;
    export const TOOLTIP: string;
    export const TOOLTIP_INDICATOR: string;
    export const TREE: string;
    export const TREE_NODE: string;
    export const TREE_NODE_CARET: string;
    export const TREE_NODE_CARET_CLOSED: string;
    export const TREE_NODE_CARET_NONE: string;
    export const TREE_NODE_CARET_OPEN: string;
    export const TREE_NODE_CONTENT: string;
    export const TREE_NODE_EXPANDED: string;
    export const TREE_NODE_ICON: string;
    export const TREE_NODE_LABEL: string;
    export const TREE_NODE_LIST: string;
    export const TREE_NODE_SECONDARY_LABEL: string;
    export const TREE_NODE_SELECTED: string;
    export const TREE_ROOT: string;
    export const ICON: string;
    export const ICON_STANDARD: string;
    export const ICON_LARGE: string;
    /**
        * Returns the namespace prefix for all Blueprint CSS classes.
        * Customize this namespace at build time with the `process.env.BLUEPRINT_NAMESPACE` environment variable.
        */
    export function getClassNamespace(): string;
    /** Return CSS class for alignment. */
    export function alignmentClass(alignment: Alignment): string;
    export function elevationClass(elevation: Elevation): string;
    /** Returns CSS class for icon name. */
    export function iconClass(iconName?: string): string;
    /** Return CSS class for intent. */
    export function intentClass(intent?: Intent): string;
    export function positionClass(position: Position): string;
}

declare module '@blueprintjs/core/common/keys' {
    export const BACKSPACE = 8;
    export const TAB = 9;
    export const ENTER = 13;
    export const SHIFT = 16;
    export const ESCAPE = 27;
    export const SPACE = 32;
    export const ARROW_LEFT = 37;
    export const ARROW_UP = 38;
    export const ARROW_RIGHT = 39;
    export const ARROW_DOWN = 40;
    export const DELETE = 46;
    /** Returns whether the key code is `enter` or `space`, the two keys that can click a button. */
    export function isKeyboardClick(keyCode: number): boolean;
}

declare module '@blueprintjs/core/common/utils' {
    import * as React from "react";
    export * from "@blueprintjs/core/common/utils/compareUtils";
    export * from "@blueprintjs/core/common/utils/safeInvokeMember";
    /** Returns whether `process.env.NODE_ENV` exists and equals `env`. */
    export function isNodeEnv(env: string): boolean;
    /** Returns whether the value is a function. Acts as a type guard. */
    export function isFunction(value: any): value is Function;
    /**
        * Returns true if `node` is null/undefined, false, empty string, or an array
        * composed of those. If `node` is an array, only one level of the array is
        * checked, for performance reasons.
        */
    export function isReactNodeEmpty(node?: React.ReactNode, skipArray?: boolean): boolean;
    /**
        * Converts a React node to an element: non-empty string or number or
        * `React.Fragment` (React 16.3+) is wrapped in given tag name; empty strings
        * and booleans are discarded.
        */
    export function ensureElement(child: React.ReactNode | undefined, tagName?: keyof JSX.IntrinsicElements): React.ReactElement<any>;
    export function isReactElement<T = any>(child: React.ReactNode): child is React.ReactElement<T>;
    /**
        * Represents anything that has a `name` property such as Functions.
        */
    export interface INamed {
            name?: string;
    }
    export function getDisplayName(ComponentClass: React.ComponentType | INamed): string;
    /**
        * Returns true if the given JSX element matches the given component type.
        *
        * NOTE: This function only checks equality of `displayName` for performance and
        * to tolerate multiple minor versions of a component being included in one
        * application bundle.
        * @param element JSX element in question
        * @param ComponentType desired component type of element
        */
    export function isElementOfType<P = {}>(element: any, ComponentType: React.ComponentType<P>): element is React.ReactElement<P>;
    /**
        * Safely invoke the function with the given arguments, if it is indeed a
        * function, and return its value. Otherwise, return undefined.
        */
    export function safeInvoke<R>(func: (() => R) | undefined): R | undefined;
    export function safeInvoke<A, R>(func: ((arg1: A) => R) | undefined, arg1: A): R | undefined;
    export function safeInvoke<A, B, R>(func: ((arg1: A, arg2: B) => R) | undefined, arg1: A, arg2: B): R | undefined;
    export function safeInvoke<A, B, C, R>(func: ((arg1: A, arg2: B, arg3: C) => R) | undefined, arg1: A, arg2: B, arg3: C): R | undefined;
    export function safeInvoke<A, B, C, D, R>(func: ((arg1: A, arg2: B, arg3: C, arg4: D) => R) | undefined, arg1: A, arg2: B, arg3: C, arg4: D): R | undefined;
    /**
        * Safely invoke the provided entity if it is a function; otherwise, return the
        * entity itself.
        */
    export function safeInvokeOrValue<R>(funcOrValue: (() => R) | R | undefined): R;
    export function safeInvokeOrValue<A, R>(funcOrValue: ((arg1: A) => R) | R | undefined, arg1: A): R;
    export function safeInvokeOrValue<A, B, R>(funcOrValue: ((arg1: A, arg2: B) => R) | R | undefined, arg1: A, arg2: B): R;
    export function safeInvokeOrValue<A, B, C, R>(funcOrValue: ((arg1: A, arg2: B, arg3: C) => R) | R | undefined, arg1: A, arg2: B, arg3: C): R;
    export function safeInvokeOrValue<A, B, C, D, R>(funcOrValue: ((arg1: A, arg2: B, arg3: C, arg4: D) => R) | R | undefined, arg1: A, arg2: B, arg3: C, arg4: D): R;
    export function elementIsOrContains(element: HTMLElement, testElement: HTMLElement): boolean;
    /**
        * Returns the difference in length between two arrays. A `null` argument is
        * considered an empty list. The return value will be positive if `a` is longer
        * than `b`, negative if the opposite is true, and zero if their lengths are
        * equal.
        */
    export function arrayLengthCompare(a?: any[], b?: any[]): number;
    /**
        * Returns true if the two numbers are within the given tolerance of each other.
        * This is useful to correct for floating point precision issues, less useful
        * for integers.
        */
    export function approxEqual(a: number, b: number, tolerance?: number): boolean;
    /**
        * Clamps the given number between min and max values. Returns value if within
        * range, or closest bound.
        */
    export function clamp(val: number, min: number, max: number): number;
    /** Returns the number of decimal places in the given number. */
    export function countDecimalPlaces(num: number): number;
    /**
        * Throttle an event on an EventTarget by wrapping it in a
        * `requestAnimationFrame` call. Returns the event handler that was bound to
        * given eventName so you can clean up after yourself.
        * @see https://developer.mozilla.org/en-US/docs/Web/Events/scroll
        */
    export function throttleEvent(target: EventTarget, eventName: string, newEventName: string): (event: Event) => void;
    export interface IThrottledReactEventOptions {
            preventDefault?: boolean;
    }
    /**
        * Throttle a callback by wrapping it in a `requestAnimationFrame` call. Returns
        * the throttled function.
        * @see https://www.html5rocks.com/en/tutorials/speed/animations/
        */
    export function throttleReactEventCallback(callback: (event: React.SyntheticEvent<any>, ...otherArgs: any[]) => any, options?: IThrottledReactEventOptions): (event2: React.SyntheticEvent<any>) => void;
    /**
        * Throttle a method by wrapping it in a `requestAnimationFrame` call. Returns
        * the throttled function.
        */
    export function throttle<T extends Function>(method: T): T;
}

declare module '@blueprintjs/core/components/context-menu/contextMenu' {
    export interface IOffset {
        left: number;
        top: number;
    }
    /**
      * Show the given menu element at the given offset from the top-left corner of the viewport.
      * The menu will appear below-right of this point and will flip to below-left if there is not enough
      * room onscreen. The optional callback will be invoked when this menu closes.
      */
    export function show(menu: JSX.Element, offset: IOffset, onClose?: () => void, isDarkTheme?: boolean): void;
    /** Hide the open context menu. */
    export function hide(): void;
    /** Return whether a context menu is currently open. */
    export function isOpen(): boolean;
}

declare module '@blueprintjs/core/components/alert/alert' {
    import * as React from "react";
    import { AbstractPureComponent, Intent, IProps, MaybeElement } from "@blueprintjs/core/common";
    import { IconName } from "@blueprintjs/core/components/icon/icon";
    import { IOverlayLifecycleProps } from "@blueprintjs/core/components/overlay/overlay";
    export interface IAlertProps extends IOverlayLifecycleProps, IProps {
            /**
                * Whether pressing <kbd>escape</kbd> when focused on the Alert should cancel the alert.
                * If this prop is enabled, then either `onCancel` or `onClose` must also be defined.
                * @default false
                */
            canEscapeKeyCancel?: boolean;
            /**
                * Whether clicking outside the Alert should cancel the alert.
                * If this prop is enabled, then either `onCancel` or `onClose` must also be defined.
                * @default false
                */
            canOutsideClickCancel?: boolean;
            /**
                * The text for the cancel button.
                * If this prop is defined, then either `onCancel` or `onClose` must also be defined.
                */
            cancelButtonText?: string;
            /**
                * The text for the confirm (right-most) button.
                * This button will always appear, and uses the value of the `intent` prop below.
                * @default "OK"
                */
            confirmButtonText?: string;
            /** Name of a Blueprint UI icon (or an icon element) to display on the left side. */
            icon?: IconName | MaybeElement;
            /**
                * The intent to be applied to the confirm (right-most) button.
                */
            intent?: Intent;
            /**
                * Toggles the visibility of the alert.
                * This prop is required because the component is controlled.
                */
            isOpen: boolean;
            /**
                * CSS styles to apply to the alert.
                */
            style?: React.CSSProperties;
            /**
                * Indicates how long (in milliseconds) the overlay's enter/leave transition takes.
                * This is used by React `CSSTransition` to know when a transition completes and must match
                * the duration of the animation in CSS. Only set this prop if you override Blueprint's default
                * transitions with new transitions of a different length.
                * @default 300
                */
            transitionDuration?: number;
            /**
                * The container element into which the overlay renders its contents, when `usePortal` is `true`.
                * This prop is ignored if `usePortal` is `false`.
                * @default document.body
                */
            portalContainer?: HTMLElement;
            /**
                * Handler invoked when the alert is canceled. Alerts can be **canceled** in the following ways:
                * - clicking the cancel button (if `cancelButtonText` is defined)
                * - pressing the escape key (if `canEscapeKeyCancel` is enabled)
                * - clicking on the overlay backdrop (if `canOutsideClickCancel` is enabled)
                *
                * If any of the `cancel` props are defined, then either `onCancel` or `onClose` must be defined.
                */
            onCancel?(evt?: React.SyntheticEvent<HTMLElement>): void;
            /**
                * Handler invoked when the confirm button is clicked. Alerts can be **confirmed** in the following ways:
                * - clicking the confirm button
                * - focusing on the confirm button and pressing `enter` or `space`
                */
            onConfirm?(evt?: React.SyntheticEvent<HTMLElement>): void;
            /**
                * Handler invoked when the Alert is confirmed or canceled; see `onConfirm` and `onCancel` for more details.
                * First argument is `true` if confirmed, `false` otherwise.
                * This is an alternative to defining separate `onConfirm` and `onCancel` handlers.
                */
            onClose?(confirmed: boolean, evt?: React.SyntheticEvent<HTMLElement>): void;
    }
    export class Alert extends AbstractPureComponent<IAlertProps, {}> {
            static defaultProps: IAlertProps;
            static displayName: string;
            render(): JSX.Element;
            protected validateProps(props: IAlertProps): void;
    }
}

declare module '@blueprintjs/core/components/breadcrumbs/breadcrumb' {
    import * as React from "react";
    import { IActionProps, ILinkProps } from "@blueprintjs/core/common/props";
    export interface IBreadcrumbProps extends IActionProps, ILinkProps {
        /** Whether this breadcrumb is the current breadcrumb. */
        current?: boolean;
    }
    export const Breadcrumb: React.SFC<IBreadcrumbProps>;
}

declare module '@blueprintjs/core/components/breadcrumbs/breadcrumbs' {
    import * as React from "react";
    import { Boundary } from "@blueprintjs/core/common/boundary";
    import { IProps } from "@blueprintjs/core/common/props";
    import { IOverflowListProps } from "@blueprintjs/core/components/overflow-list/overflowList";
    import { IPopoverProps } from "@blueprintjs/core/components/popover/popover";
    import { IBreadcrumbProps } from "@blueprintjs/core/components/breadcrumbs/breadcrumb";
    export interface IBreadcrumbsProps extends IProps {
            /**
                * Callback invoked to render visible breadcrumbs. Best practice is to
                * render a `<Breadcrumb>` element. If `currentBreadcrumbRenderer` is also
                * supplied, that callback will be used for the current breadcrumb instead.
                * @default Breadcrumb
                */
            breadcrumbRenderer?: (props: IBreadcrumbProps) => JSX.Element;
            /**
                * Which direction the breadcrumbs should collapse from: start or end.
                * @default Boundary.START
                */
            collapseFrom?: Boundary;
            /**
                * Callback invoked to render the current breadcrumb, which is the last
                * element in the `items` array.
                *
                * If this prop is omitted, `breadcrumbRenderer` will be invoked for the
                * current breadcrumb instead.
                */
            currentBreadcrumbRenderer?: (props: IBreadcrumbProps) => JSX.Element;
            /**
                * All breadcrumbs to display. Breadcrumbs that do not fit in the container
                * will be rendered in an overflow menu instead.
                */
            items: IBreadcrumbProps[];
            /**
                * The minimum number of visible breadcrumbs that should never collapse into
                * the overflow menu, regardless of DOM dimensions.
                * @default 0
                */
            minVisibleItems?: number;
            /**
                * Props to spread to `OverflowList`. Note that `items`,
                * `overflowRenderer`, and `visibleItemRenderer` cannot be changed.
                */
            overflowListProps?: Partial<IOverflowListProps<IBreadcrumbProps>>;
            /**
                * Props to spread to the `Popover` showing the overflow menu.
                */
            popoverProps?: IPopoverProps;
    }
    export class Breadcrumbs extends React.PureComponent<IBreadcrumbsProps> {
            static defaultProps: Partial<IBreadcrumbsProps>;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/button/buttons' {
    import * as React from "react";
    import { AbstractButton, IButtonProps } from "@blueprintjs/core/components/button/abstractButton";
    export { IButtonProps };
    export class Button extends AbstractButton<React.ButtonHTMLAttributes<HTMLButtonElement>> {
        static displayName: string;
        render(): JSX.Element;
    }
    export class AnchorButton extends AbstractButton<React.AnchorHTMLAttributes<HTMLAnchorElement>> {
        static displayName: string;
        render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/button/buttonGroup' {
    import * as React from "react";
    import { Alignment } from "@blueprintjs/core/common/alignment";
    import { HTMLDivProps, IProps } from "@blueprintjs/core/common/props";
    export interface IButtonGroupProps extends IProps, HTMLDivProps {
            /**
                * Text alignment within button. By default, icons and text will be centered
                * within the button. Passing `"left"` or `"right"` will align the button
                * text to that side and push `icon` and `rightIcon` to either edge. Passing
                * `"center"` will center the text and icons together.
                */
            alignText?: Alignment;
            /**
                * Whether the button group should take up the full width of its container.
                * @default false
                */
            fill?: boolean;
            /**
                * Whether the child buttons should appear with minimal styling.
                * @default false
                */
            minimal?: boolean;
            /**
                * Whether the child buttons should appear with large styling.
                * @default false
                */
            large?: boolean;
            /**
                * Whether the button group should appear with vertical styling.
                * @default false
                */
            vertical?: boolean;
    }
    export class ButtonGroup extends React.PureComponent<IButtonGroupProps, {}> {
            static displayName: string;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/callout/callout' {
    import * as React from "react";
    import { HTMLDivProps, IIntentProps, Intent, IProps, MaybeElement } from "@blueprintjs/core/common";
    import { IconName } from "@blueprintjs/core/components/icon/icon";
    /** This component also supports the full range of HTML `<div>` props. */
    export interface ICalloutProps extends IIntentProps, IProps, HTMLDivProps {
            /**
                * Name of a Blueprint UI icon (or an icon element) to render on the left side.
                *
                * If this prop is omitted or `undefined`, the `intent` prop will determine a default icon.
                * If this prop is explicitly `null`, no icon will be displayed (regardless of `intent`).
                */
            icon?: IconName | MaybeElement;
            /**
                * Visual intent color to apply to background, title, and icon.
                *
                * Defining this prop also applies a default icon, if the `icon` prop is omitted.
                */
            intent?: Intent;
            /**
                * String content of optional title element.
                *
                * Due to a conflict with the HTML prop types, to provide JSX content simply
                * pass `<H4>JSX title content</H4>` as first `children` element instead of
                * using this prop (note uppercase tag name to use the Blueprint Heading
                * component).
                */
            title?: string;
    }
    export class Callout extends React.PureComponent<ICalloutProps, {}> {
            static displayName: string;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/card/card' {
    import * as React from "react";
    import { Elevation } from "@blueprintjs/core/common/elevation";
    import { HTMLDivProps, IProps } from "@blueprintjs/core/common/props";
    export interface ICardProps extends IProps, HTMLDivProps {
            /**
                * Controls the intensity of the drop shadow beneath the card: the higher
                * the elevation, the higher the drop shadow. At elevation `0`, no drop
                * shadow is applied.
                *
                * @default 0
                */
            elevation?: Elevation;
            /**
                * Whether the card should respond to user interactions. If set to `true`,
                * hovering over the card will increase the card's elevation
                * and change the mouse cursor to a pointer.
                *
                * Recommended when `onClick` is also defined.
                *
                * @default false
                */
            interactive?: boolean;
            /**
                * Callback invoked when the card is clicked.
                * Recommended when `interactive` is `true`.
                */
            onClick?: (e: React.MouseEvent<HTMLDivElement>) => void;
    }
    export class Card extends React.PureComponent<ICardProps, {}> {
            static displayName: string;
            static defaultProps: ICardProps;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/collapse/collapse' {
    import * as React from "react";
    import { AbstractPureComponent } from "@blueprintjs/core/common/abstractPureComponent";
    import { IProps } from "@blueprintjs/core/common/props";
    export interface ICollapseProps extends IProps {
            /**
                * Component to render as the root element.
                * Useful when rendering a `Collapse` inside a `<table>`, for instance.
                * @default "div"
                */
            component?: React.ReactType;
            /**
                * Whether the component is open or closed.
                * @default false
                */
            isOpen?: boolean;
            /**
                * Whether the child components will remain mounted when the `Collapse` is closed.
                * Setting to true may improve performance by avoiding re-mounting children.
                * @default false
                */
            keepChildrenMounted?: boolean;
            /**
                * The length of time the transition takes, in milliseconds. This must match
                * the duration of the animation in CSS. Only set this prop if you override
                * Blueprint's default transitions with new transitions of a different
                * length.
                * @default 200
                */
            transitionDuration?: number;
    }
    export interface ICollapseState {
            /** The height that should be used for the content animations. This is a CSS value, not just a number. */
            height: string;
            /** The state the element is currently in. */
            animationState: AnimationStates;
    }
    /**
        * `Collapse` can be in one of six states, enumerated here.
        * When changing the `isOpen` prop, the following happens to the states:
        * isOpen={true}  : CLOSED -> OPEN_START -> OPENING -> OPEN
        * isOpen={false} : OPEN -> CLOSING_START -> CLOSING -> CLOSED
        */
    export enum AnimationStates {
            /**
                * The body is re-rendered, height is set to the measured body height and
                * the body Y is set to 0.
                */
            OPEN_START = 0,
            /**
                * Animation begins, height is set to auto. This is all animated, and on
                * complete, the state changes to OPEN.
                */
            OPENING = 1,
            /**
                * The collapse height is set to auto, and the body Y is set to 0 (so the
                * element can be seen as normal).
                */
            OPEN = 2,
            /**
                * Height has been changed from auto to the measured height of the body to
                * prepare for the closing animation in CLOSING.
                */
            CLOSING_START = 3,
            /**
                * Height is set to 0 and the body Y is at -height. Both of these properties
                * are transformed, and then after the animation is complete, the state
                * changes to CLOSED.
                */
            CLOSING = 4,
            /**
                * The contents of the collapse is not rendered, the collapse height is 0,
                * and the body Y is at -height (so that the bottom of the body is at Y=0).
                */
            CLOSED = 5,
    }
    export class Collapse extends AbstractPureComponent<ICollapseProps, ICollapseState> {
            static displayName: string;
            static defaultProps: ICollapseProps;
            state: {
                    animationState: AnimationStates;
                    height: string;
            };
            componentWillReceiveProps(nextProps: ICollapseProps): void;
            render(): React.ReactElement<any>;
            componentDidMount(): void;
            componentDidUpdate(): void;
    }
}

declare module '@blueprintjs/core/components/collapsible-list/collapsibleList' {
    import * as React from "react";
    import { Boundary } from "@blueprintjs/core/common/boundary";
    import { IProps } from "@blueprintjs/core/common/props";
    import { IMenuItemProps } from "@blueprintjs/core/components/menu/menuItem";
    import { IPopoverProps } from "@blueprintjs/core/components/popover/popover";
    export interface ICollapsibleListProps extends IProps {
            /**
                * Element to render as dropdown target with `CLICK` interaction to show collapsed menu.
                */
            dropdownTarget: JSX.Element;
            /**
                * Props to pass to the dropdown.
                */
            dropdownProps?: IPopoverProps;
            /**
                * Callback invoked to render each visible item. The item will be wrapped in an `li` with
                * the optional `visibleItemClassName` prop.
                */
            visibleItemRenderer: (props: IMenuItemProps, index: number) => JSX.Element;
            /**
                * Which direction the items should collapse from: start or end of the children.
                * @default Boundary.START
                */
            collapseFrom?: Boundary;
            /**
                * CSS class names to add to `<li>` tags containing each visible item and the dropdown.
                */
            visibleItemClassName?: string;
            /**
                * Exact number of visible items.
                * @default 3
                */
            visibleItemCount?: number;
    }
    /** @deprecated use `<OverflowList>` for automatic overflow based on available space. */
    export class CollapsibleList extends React.Component<ICollapsibleListProps, {}> {
            static displayName: string;
            static defaultProps: ICollapsibleListProps;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/context-menu/contextMenuTarget' {
    import * as React from "react";
    import { IConstructor } from "@blueprintjs/core/common/constructor";
    export interface IContextMenuTargetComponent extends React.Component {
        render(): React.ReactElement<any> | null | undefined;
        renderContextMenu(e: React.MouseEvent<HTMLElement>): JSX.Element | undefined;
        onContextMenuClose?(): void;
    }
    export function ContextMenuTarget<T extends IConstructor<IContextMenuTargetComponent>>(WrappedComponent: T): {
        new (...args: any[]): {
            render(): React.ReactElement<any>;
            renderContextMenu(e: React.MouseEvent<HTMLElement>): JSX.Element;
            onContextMenuClose?(): void;
            setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<{}>) => {} | Pick<{}, K>) | Pick<{}, K>, callback?: () => void): void;
            forceUpdate(callBack?: () => void): void;
            readonly props: Readonly<{
                children?: React.ReactNode;
            }> & Readonly<{}>;
            state: Readonly<{}>;
            context: any;
            refs: {
                [key: string]: React.ReactInstance;
            };
            componentDidMount?(): void;
            shouldComponentUpdate?(nextProps: Readonly<{}>, nextState: Readonly<{}>, nextContext: any): boolean;
            componentWillUnmount?(): void;
            componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
            getSnapshotBeforeUpdate?(prevProps: Readonly<{}>, prevState: Readonly<{}>): any;
            componentDidUpdate?(prevProps: Readonly<{}>, prevState: Readonly<{}>, snapshot?: any): void;
            componentWillMount?(): void;
            UNSAFE_componentWillMount?(): void;
            componentWillReceiveProps?(nextProps: Readonly<{}>, nextContext: any): void;
            UNSAFE_componentWillReceiveProps?(nextProps: Readonly<{}>, nextContext: any): void;
            componentWillUpdate?(nextProps: Readonly<{}>, nextState: Readonly<{}>, nextContext: any): void;
            UNSAFE_componentWillUpdate?(nextProps: Readonly<{}>, nextState: Readonly<{}>, nextContext: any): void;
        };
        displayName: string;
    } & T;
}

declare module '@blueprintjs/core/components/dialog/dialog' {
    import * as React from "react";
    import { AbstractPureComponent } from "@blueprintjs/core/common/abstractPureComponent";
    import { IProps, MaybeElement } from "@blueprintjs/core/common/props";
    import { IconName } from "@blueprintjs/core/components/icon/icon";
    import { IBackdropProps, IOverlayableProps } from "@blueprintjs/core/components/overlay/overlay";
    export interface IDialogProps extends IOverlayableProps, IBackdropProps, IProps {
            /**
                * Toggles the visibility of the overlay and its children.
                * This prop is required because the component is controlled.
                */
            isOpen: boolean;
            /**
                * Name of a Blueprint UI icon (or an icon element) to render in the
                * dialog's header. Note that the header will only be rendered if `title` is
                * provided.
                */
            icon?: IconName | MaybeElement;
            /**
                * Whether to show the close button in the dialog's header.
                * Note that the header will only be rendered if `title` is provided.
                * @default true
                */
            isCloseButtonShown?: boolean;
            /**
                * CSS styles to apply to the dialog.
                * @default {}
                */
            style?: React.CSSProperties;
            /**
                * Title of the dialog. If provided, an element with `Classes.DIALOG_HEADER`
                * will be rendered inside the dialog before any children elements.
                */
            title?: React.ReactNode;
            /**
                * Name of the transition for internal `CSSTransition`. Providing your own
                * name here will require defining new CSS transition properties.
                */
            transitionName?: string;
    }
    export class Dialog extends AbstractPureComponent<IDialogProps, {}> {
            static defaultProps: IDialogProps;
            static displayName: string;
            render(): JSX.Element;
            protected validateProps(props: IDialogProps): void;
    }
}

declare module '@blueprintjs/core/components/divider/divider' {
    import * as React from "react";
    import { IProps } from "@blueprintjs/core/common/props";
    export interface IDividerProps extends IProps, React.HTMLAttributes<HTMLElement> {
        /**
          * HTML tag to use for element.
          * @default "div"
          */
        tagName?: keyof JSX.IntrinsicElements;
    }
    export class Divider extends React.PureComponent<IDividerProps> {
        static displayName: string;
        render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/drawer/drawer' {
    import * as React from "react";
    import { AbstractPureComponent } from "@blueprintjs/core/common/abstractPureComponent";
    import { Position } from "@blueprintjs/core/common/position";
    import { IProps, MaybeElement } from "@blueprintjs/core/common/props";
    import { IconName } from "@blueprintjs/core/components/icon/icon";
    import { IBackdropProps, IOverlayableProps } from "@blueprintjs/core/components/overlay/overlay";
    export interface IDrawerProps extends IOverlayableProps, IBackdropProps, IProps {
            /**
                * Name of a Blueprint UI icon (or an icon element) to render in the
                * drawer's header. Note that the header will only be rendered if `title` is
                * provided.
                */
            icon?: IconName | MaybeElement;
            /**
                * Whether to show the close button in the dialog's header.
                * Note that the header will only be rendered if `title` is provided.
                * @default true
                */
            isCloseButtonShown?: boolean;
            /**
                * Toggles the visibility of the overlay and its children.
                * This prop is required because the component is controlled.
                */
            isOpen: boolean;
            /**
                * Position of a drawer. All angled positions will be casted into pure positions
                * (TOP, BOTTOM, LEFT or RIGHT).
                * @default Position.RIGHT
                */
            position?: Position;
            /**
                * CSS size of the drawer. This sets `width` if `vertical={false}` (default)
                * and `height` otherwise.
                *
                * Constants are available for common sizes:
                * - `Drawer.SIZE_SMALL = 360px`
                * - `Drawer.SIZE_STANDARD = 50%`
                * - `Drawer.SIZE_LARGE = 90%`
                *
                * @default Drawer.SIZE_STANDARD = "50%"
                */
            size?: number | string;
            /**
                * CSS styles to apply to the dialog.
                * @default {}
                */
            style?: React.CSSProperties;
            /**
                * Title of the dialog. If provided, an element with `Classes.DIALOG_HEADER`
                * will be rendered inside the dialog before any children elements.
                */
            title?: React.ReactNode;
            /**
                * Name of the transition for internal `CSSTransition`. Providing your own
                * name here will require defining new CSS transition properties.
                */
            transitionName?: string;
            /**
                * Whether the drawer should appear with vertical styling.
                * It will be ignored if `position` prop is set
                * @default false
                * @deprecated use `position` instead
                */
            vertical?: boolean;
    }
    export class Drawer extends AbstractPureComponent<IDrawerProps, {}> {
            static displayName: string;
            static defaultProps: IDrawerProps;
            static readonly SIZE_SMALL: string;
            static readonly SIZE_STANDARD: string;
            static readonly SIZE_LARGE: string;
            render(): JSX.Element;
            protected validateProps(props: IDrawerProps): void;
    }
}

declare module '@blueprintjs/core/components/editable-text/editableText' {
    import { AbstractPureComponent } from "@blueprintjs/core/common/abstractPureComponent";
    import { IIntentProps, IProps } from "@blueprintjs/core/common/props";
    export interface IEditableTextProps extends IIntentProps, IProps {
            /**
                * If `true` and in multiline mode, the `enter` key will trigger onConfirm and `mod+enter`
                * will insert a newline. If `false`, the key bindings are inverted such that `enter`
                * adds a newline.
                * @default false
                */
            confirmOnEnterKey?: boolean;
            /** Default text value of uncontrolled input. */
            defaultValue?: string;
            /**
                * Whether the text can be edited.
                * @default false
                */
            disabled?: boolean;
            /** Whether the component is currently being edited. */
            isEditing?: boolean;
            /** Maximum number of characters allowed. Unlimited by default. */
            maxLength?: number;
            /** Minimum width in pixels of the input, when not `multiline`. */
            minWidth?: number;
            /**
                * Whether the component supports multiple lines of text.
                * This prop should not be changed during the component's lifetime.
                * @default false
                */
            multiline?: boolean;
            /**
                * Maximum number of lines before scrolling begins, when `multiline`.
                */
            maxLines?: number;
            /**
                * Minimum number of lines (essentially minimum height), when `multiline`.
                * @default 1
                */
            minLines?: number;
            /**
                * Placeholder text when there is no value.
                * @default "Click to Edit"
                */
            placeholder?: string;
            /**
                * Whether the entire text field should be selected on focus.
                * If `false`, the cursor is placed at the end of the text.
                * @default false
                */
            selectAllOnFocus?: boolean;
            /**
                * The type of input that should be shown, when not `multiline`.
                */
            type?: string;
            /** Text value of controlled input. */
            value?: string;
            /** Callback invoked when user cancels input with the `esc` key. Receives last confirmed value. */
            onCancel?(value: string): void;
            /** Callback invoked when user changes input in any way. */
            onChange?(value: string): void;
            /** Callback invoked when user confirms value with `enter` key or by blurring input. */
            onConfirm?(value: string): void;
            /** Callback invoked after the user enters edit mode. */
            onEdit?(value: string): void;
    }
    export interface IEditableTextState {
            /** Pixel height of the input, measured from span size */
            inputHeight?: number;
            /** Pixel width of the input, measured from span size */
            inputWidth?: number;
            /** Whether the value is currently being edited */
            isEditing?: boolean;
            /** The last confirmed value */
            lastValue?: string;
            /** The controlled input value, may be different from prop during editing */
            value?: string;
    }
    export class EditableText extends AbstractPureComponent<IEditableTextProps, IEditableTextState> {
            static displayName: string;
            static defaultProps: IEditableTextProps;
            constructor(props?: IEditableTextProps, context?: any);
            render(): JSX.Element;
            componentDidMount(): void;
            componentDidUpdate(_: IEditableTextProps, prevState: IEditableTextState): void;
            componentWillReceiveProps(nextProps: IEditableTextProps): void;
            cancelEditing: () => void;
            toggleEditing: () => void;
    }
}

declare module '@blueprintjs/core/components/forms/controlGroup' {
    import * as React from "react";
    import { HTMLDivProps, IProps } from "@blueprintjs/core/common/props";
    export interface IControlGroupProps extends IProps, HTMLDivProps {
            /**
                * Whether the control group should take up the full width of its container.
                * @default false
                */
            fill?: boolean;
            /**
                * Whether the control group should appear with vertical styling.
                * @default false
                */
            vertical?: boolean;
    }
    export class ControlGroup extends React.PureComponent<IControlGroupProps, {}> {
            static displayName: string;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/forms/controls' {
    import * as React from "react";
    import { Alignment } from "@blueprintjs/core/common/alignment";
    import { HTMLInputProps, IProps } from "@blueprintjs/core/common/props";
    export interface IControlProps extends IProps, HTMLInputProps {
            /**
                * Alignment of the indicator within container.
                * @default Alignment.LEFT
                */
            alignIndicator?: Alignment;
            /** Whether the control is checked. */
            checked?: boolean;
            /** JSX label for the control. */
            children?: React.ReactNode;
            /** Whether the control is initially checked (uncontrolled mode). */
            defaultChecked?: boolean;
            /** Whether the control is non-interactive. */
            disabled?: boolean;
            /** Ref handler that receives HTML `<input>` element backing this component. */
            inputRef?: (ref: HTMLInputElement | null) => any;
            /** Whether the control should appear as an inline element. */
            inline?: boolean;
            /**
                * Text label for the control.
                *
                * Use `children` or `labelElement` to supply JSX content. This prop actually supports JSX elements,
                * but TypeScript will throw an error because `HTMLAttributes` only allows strings.
                */
            label?: string;
            /**
                * JSX Element label for the control.
                *
                * This prop is a workaround for TypeScript consumers as the type definition for `label` only
                * accepts strings. JavaScript consumers can provide a JSX element directly to `label`.
                */
            labelElement?: React.ReactNode;
            /** Whether this control should use large styles. */
            large?: boolean;
            /** Event handler invoked when input value is changed. */
            onChange?: React.FormEventHandler<HTMLInputElement>;
            /**
                * Name of the HTML tag that wraps the checkbox.
                *
                * By default a `<label>` is used, which effectively enlarges the click
                * target to include all of its children. Supply a different tag name if
                * this behavior is undesirable or you're listening to click events from a
                * parent element (as the label can register duplicate clicks).
                *
                * @default "label"
                */
            tagName?: keyof JSX.IntrinsicElements;
    }
    export interface ISwitchProps extends IControlProps {
            /**
                * Text to display inside the switch indicator when checked.
                * If `innerLabel` is provided and this prop is omitted, then `innerLabel`
                * will be used for both states.
                * @default innerLabel
                */
            innerLabelChecked?: string;
            /**
                * Text to display inside the switch indicator when unchecked.
                */
            innerLabel?: string;
    }
    export class Switch extends React.PureComponent<ISwitchProps> {
            static displayName: string;
            render(): JSX.Element;
    }
    export interface IRadioProps extends IControlProps {
    }
    export class Radio extends React.PureComponent<IRadioProps> {
            static displayName: string;
            render(): JSX.Element;
    }
    export interface ICheckboxProps extends IControlProps {
            /** Whether this checkbox is initially indeterminate (uncontrolled mode). */
            defaultIndeterminate?: boolean;
            /**
                * Whether this checkbox is indeterminate, or "partially checked."
                * The checkbox will appear with a small dash instead of a tick to indicate that the value
                * is not exactly true or false.
                *
                * Note that this prop takes precendence over `checked`: if a checkbox is marked both
                * `checked` and `indeterminate` via props, it will appear as indeterminate in the DOM.
                */
            indeterminate?: boolean;
    }
    export interface ICheckboxState {
            indeterminate: boolean;
    }
    export class Checkbox extends React.PureComponent<ICheckboxProps, ICheckboxState> {
            static displayName: string;
            state: ICheckboxState;
            render(): JSX.Element;
            componentWillReceiveProps({indeterminate}: ICheckboxProps): void;
            componentDidMount(): void;
            componentDidUpdate(): void;
    }
}

declare module '@blueprintjs/core/components/forms/fileInput' {
    import * as React from "react";
    import { IProps } from "@blueprintjs/core/common/props";
    export interface IFileInputProps extends React.LabelHTMLAttributes<HTMLLabelElement>, IProps {
            /**
                * Whether the file input is non-interactive.
                * Setting this to `true` will automatically disable the child input too.
                */
            disabled?: boolean;
            /**
                * Whether the file input should take up the full width of its container.
                */
            fill?: boolean;
            /**
                * Whether the user has made a selection in the input. This will affect the component's
                * text styling. Make sure to set a non-empty value for the text prop as well.
                * @default false
                */
            hasSelection?: boolean;
            /**
                * The props to pass to the child input.
                * `disabled` will be ignored in favor of the top-level prop.
                * `type` will be ignored, because the input _must_ be `type="file"`.
                * Pass `onChange` here to be notified when the user selects a file.
                */
            inputProps?: React.HTMLProps<HTMLInputElement>;
            /**
                * Whether the file input should appear with large styling.
                */
            large?: boolean;
            /**
                * Callback invoked on `<input>` `change` events.
                *
                * This callback is offered as a convenience; it is equivalent to passing
                * `onChange` to `inputProps`.
                *
                * __Note:__ The top-level `onChange` prop is passed to the wrapping
                * `<label>` rather than the `<input>`, which may not be what you expect.
                */
            onInputChange?: React.FormEventHandler<HTMLInputElement>;
            /**
                * The text to display.
                * @default "Choose file..."
                */
            text?: React.ReactNode;
    }
    export class FileInput extends React.PureComponent<IFileInputProps, {}> {
            static displayName: string;
            static defaultProps: IFileInputProps;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/forms/formGroup' {
    import * as React from "react";
    import { IIntentProps, IProps } from "@blueprintjs/core/common/props";
    export interface IFormGroupProps extends IIntentProps, IProps {
            /**
                * A space-delimited list of class names to pass along to the
                * `Classes.FORM_CONTENT` element that contains `children`.
                */
            contentClassName?: string;
            /**
                * Whether form group should appear as non-interactive.
                * Remember that `input` elements must be disabled separately.
                */
            disabled?: boolean;
            /**
                * Optional helper text. The given content will be wrapped in
                * `Classes.FORM_HELPER_TEXT` and displayed beneath `children`.
                * Helper text color is determined by the `intent`.
                */
            helperText?: React.ReactNode;
            /** Whether to render the label and children on a single line. */
            inline?: boolean;
            /** Label of this form group. */
            label?: React.ReactNode;
            /**
                * `id` attribute of the labelable form element that this `FormGroup` controls,
                * used as `<label for>` attribute.
                */
            labelFor?: string;
            /**
                * Optional secondary text that appears after the label.
                */
            labelInfo?: React.ReactNode;
            /** CSS properties to apply to the root element. */
            style?: React.CSSProperties;
    }
    export class FormGroup extends React.PureComponent<IFormGroupProps, {}> {
            static displayName: string;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/forms/inputGroup' {
    import * as React from "react";
    import { HTMLInputProps, IControlledProps, IIntentProps, IProps, MaybeElement } from "@blueprintjs/core/common/props";
    import { IconName } from "@blueprintjs/core/components/icon/icon";
    export interface IInputGroupProps extends IControlledProps, IIntentProps, IProps {
            /**
                * Whether the input is non-interactive.
                * Note that `rightElement` must be disabled separately; this prop will not affect it.
                * @default false
                */
            disabled?: boolean;
            /** Ref handler that receives HTML `<input>` element backing this component. */
            inputRef?: (ref: HTMLInputElement | null) => any;
            /**
                * Name of a Blueprint UI icon (or an icon element) to render on the left side of the input group,
                * before the user's cursor.
                */
            leftIcon?: IconName | MaybeElement;
            /** Whether this input should use large styles. */
            large?: boolean;
            /** Whether this input should use small styles. */
            small?: boolean;
            /** Placeholder text in the absence of any value. */
            placeholder?: string;
            /**
                * Element to render on right side of input.
                * For best results, use a minimal button, tag, or small spinner.
                */
            rightElement?: JSX.Element;
            /** Whether the input (and any buttons) should appear with rounded caps. */
            round?: boolean;
            /**
                * HTML `input` type attribute.
                * @default "text"
                */
            type?: string;
    }
    export interface IInputGroupState {
            rightElementWidth: number;
    }
    export class InputGroup extends React.PureComponent<IInputGroupProps & HTMLInputProps, IInputGroupState> {
            static displayName: string;
            state: IInputGroupState;
            render(): JSX.Element;
            componentDidMount(): void;
            componentDidUpdate(): void;
    }
}

declare module '@blueprintjs/core/components/forms/numericInput' {
    import { IconName } from "@blueprintjs/icons";
    import { AbstractPureComponent, HTMLInputProps, IIntentProps, IProps, MaybeElement, Position } from "@blueprintjs/core/common";
    export interface INumericInputProps extends IIntentProps, IProps {
            /**
                * Whether to allow only floating-point number characters in the field,
                * mimicking the native `input[type="number"]`.
                * @default true
                */
            allowNumericCharactersOnly?: boolean;
            /**
                * The position of the buttons with respect to the input field.
                * @default Position.RIGHT
                */
            buttonPosition?: typeof Position.LEFT | typeof Position.RIGHT | "none";
            /**
                * Whether the value should be clamped to `[min, max]` on blur.
                * The value will be clamped to each bound only if the bound is defined.
                * Note that native `input[type="number"]` controls do *NOT* clamp on blur.
                * @default false
                */
            clampValueOnBlur?: boolean;
            /**
                * Whether the input is non-interactive.
                * @default false
                */
            disabled?: boolean;
            /** Whether the numeric input should take up the full width of its container. */
            fill?: boolean;
            /**
                * Ref handler that receives HTML `<input>` element backing this component.
                */
            inputRef?: (ref: HTMLInputElement | null) => any;
            /**
                * If set to `true`, the input will display with larger styling.
                * This is equivalent to setting `Classes.LARGE` via className on the
                * parent control group and on the child input group.
                * @default false
                */
            large?: boolean;
            /**
                * Name of a Blueprint UI icon (or an icon element) to render on the left side of input.
                */
            leftIcon?: IconName | MaybeElement;
            /**
                * The increment between successive values when <kbd>shift</kbd> is held.
                * Pass explicit `null` value to disable this interaction.
                * @default 10
                */
            majorStepSize?: number | null;
            /** The maximum value of the input. */
            max?: number;
            /** The minimum value of the input. */
            min?: number;
            /**
                * The increment between successive values when <kbd>alt</kbd> is held.
                * Pass explicit `null` value to disable this interaction.
                * @default 0.1
                */
            minorStepSize?: number | null;
            /** The placeholder text in the absence of any value. */
            placeholder?: string;
            /**
                * Element to render on right side of input.
                * For best results, use a minimal button, tag, or small spinner.
                */
            rightElement?: JSX.Element;
            /**
                * Whether the entire text field should be selected on focus.
                * @default false
                */
            selectAllOnFocus?: boolean;
            /**
                * Whether the entire text field should be selected on increment.
                * @default false
                */
            selectAllOnIncrement?: boolean;
            /**
                * The increment between successive values when no modifier keys are held.
                * @default 1
                */
            stepSize?: number;
            /** The value to display in the input field. */
            value?: number | string;
            /** The callback invoked when the value changes due to a button click. */
            onButtonClick?(valueAsNumber: number, valueAsString: string): void;
            /** The callback invoked when the value changes due to typing, arrow keys, or button clicks. */
            onValueChange?(valueAsNumber: number, valueAsString: string): void;
    }
    export interface INumericInputState {
            shouldSelectAfterUpdate: boolean;
            stepMaxPrecision: number;
            value: string;
    }
    export class NumericInput extends AbstractPureComponent<HTMLInputProps & INumericInputProps, INumericInputState> {
            static displayName: string;
            static VALUE_EMPTY: string;
            static VALUE_ZERO: string;
            static defaultProps: INumericInputProps;
            state: INumericInputState;
            componentWillReceiveProps(nextProps: HTMLInputProps & INumericInputProps): void;
            render(): JSX.Element;
            componentDidUpdate(): void;
            protected validateProps(nextProps: HTMLInputProps & INumericInputProps): void;
    }
}

declare module '@blueprintjs/core/components/forms/radioGroup' {
    import * as React from "react";
    import { AbstractPureComponent } from "@blueprintjs/core/common/abstractPureComponent";
    import { IOptionProps, IProps } from "@blueprintjs/core/common/props";
    export interface IRadioGroupProps extends IProps {
            /**
                * Whether the group and _all_ its radios are disabled.
                * Individual radios can be disabled using their `disabled` prop.
                */
            disabled?: boolean;
            /**
                * Whether the radio buttons are to be displayed inline horizontally.
                */
            inline?: boolean;
            /** Optional label text to display above the radio buttons. */
            label?: string;
            /**
                * Name of the group, used to link radio buttons together in HTML.
                * If omitted, a unique name will be generated internally.
                */
            name?: string;
            /**
                * Callback invoked when the currently selected radio changes.
                * Use `event.currentTarget.value` to read the currently selected value.
                * This prop is required because this component only supports controlled usage.
                */
            onChange: (event: React.FormEvent<HTMLInputElement>) => void;
            /**
                * Array of options to render in the group. This prop is mutually exclusive
                * with `children`: either provide an array of `IOptionProps` objects or
                * provide `<Radio>` children elements.
                */
            options?: IOptionProps[];
            /** Value of the selected radio. The child with this value will be `:checked`. */
            selectedValue?: string | number;
    }
    export class RadioGroup extends AbstractPureComponent<IRadioGroupProps, {}> {
            static displayName: string;
            render(): JSX.Element;
            protected validateProps(): void;
    }
}

declare module '@blueprintjs/core/components/forms/textArea' {
    import * as React from "react";
    import { IIntentProps, IProps } from "@blueprintjs/core/common/props";
    export interface ITextAreaProps extends IIntentProps, IProps, React.TextareaHTMLAttributes<HTMLTextAreaElement> {
            /**
                * Whether the text area should take up the full width of its container.
                */
            fill?: boolean;
            /**
                * Whether the text area should appear with large styling.
                */
            large?: boolean;
            /**
                * Whether the text area should appear with small styling.
                */
            small?: boolean;
            /**
                * Whether the text area should automatically grow vertically to accomodate content.
                */
            growVertically?: boolean;
            /**
                * Ref handler that receives HTML `<textarea>` element backing this component.
                */
            inputRef?: (ref: HTMLTextAreaElement | null) => any;
    }
    export interface ITextAreaState {
            height?: number;
    }
    export class TextArea extends React.PureComponent<ITextAreaProps, ITextAreaState> {
            static displayName: string;
            state: ITextAreaState;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/html/html' {
    import * as React from "react";
    export interface IElementRefProps<E extends HTMLElement> {
        /** Ref handler to access the instance of the internal HTML element. */
        elementRef?: (ref: E | null) => void;
    }
    export const H1: React.StatelessComponent<React.HTMLProps<HTMLHeadingElement> & IElementRefProps<HTMLHeadingElement>>;
    export const H2: React.StatelessComponent<React.HTMLProps<HTMLHeadingElement> & IElementRefProps<HTMLHeadingElement>>;
    export const H3: React.StatelessComponent<React.HTMLProps<HTMLHeadingElement> & IElementRefProps<HTMLHeadingElement>>;
    export const H4: React.StatelessComponent<React.HTMLProps<HTMLHeadingElement> & IElementRefProps<HTMLHeadingElement>>;
    export const H5: React.StatelessComponent<React.HTMLProps<HTMLHeadingElement> & IElementRefProps<HTMLHeadingElement>>;
    export const H6: React.StatelessComponent<React.HTMLProps<HTMLHeadingElement> & IElementRefProps<HTMLHeadingElement>>;
    export const Blockquote: React.StatelessComponent<React.HTMLProps<HTMLElement> & IElementRefProps<HTMLElement>>;
    export const Code: React.StatelessComponent<React.HTMLProps<HTMLElement> & IElementRefProps<HTMLElement>>;
    export const Pre: React.StatelessComponent<React.HTMLProps<HTMLElement> & IElementRefProps<HTMLElement>>;
    export const Label: React.StatelessComponent<React.HTMLProps<HTMLLabelElement> & IElementRefProps<HTMLLabelElement>>;
    export const OL: React.StatelessComponent<React.HTMLProps<HTMLOListElement> & IElementRefProps<HTMLOListElement>>;
    export const UL: React.StatelessComponent<React.HTMLProps<HTMLUListElement> & IElementRefProps<HTMLUListElement>>;
}

declare module '@blueprintjs/core/components/html-select/htmlSelect' {
    import * as React from "react";
    import { IOptionProps } from "@blueprintjs/core/common/props";
    import { IElementRefProps } from "@blueprintjs/core/components/html/html";
    import { IIconProps } from "@blueprintjs/core/components/icon/icon";
    export interface IHTMLSelectProps extends IElementRefProps<HTMLSelectElement>, React.SelectHTMLAttributes<HTMLSelectElement> {
            /** Whether this element is non-interactive. */
            disabled?: boolean;
            /** Whether this element should fill its container. */
            fill?: boolean;
            /** Props to spread to the `<Icon>` element. */
            iconProps?: Partial<IIconProps>;
            /** Whether to use large styles. */
            large?: boolean;
            /** Whether to use minimal styles. */
            minimal?: boolean;
            /** Multiple select is not supported. */
            multiple?: never;
            /** Change event handler. Use `event.currentTarget.value` to access the new value. */
            onChange?: React.ChangeEventHandler<HTMLSelectElement>;
            /**
                * Shorthand for supplying options: an array of basic types or
                * `{ label?, value }` objects. If no `label` is supplied, `value`
                * will be used as the label.
                */
            options?: Array<string | number | IOptionProps>;
            /** Controlled value of this component. */
            value?: string | number;
    }
    export class HTMLSelect extends React.PureComponent<IHTMLSelectProps> {
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/html-table/htmlTable' {
    import * as React from "react";
    import { IElementRefProps } from "@blueprintjs/core/components/html/html";
    export interface IHTMLTableProps extends React.TableHTMLAttributes<HTMLTableElement>, IElementRefProps<HTMLTableElement> {
            /** Enables borders between rows and cells. */
            bordered?: boolean;
            /** Use small, condensed appearance. */
            condensed?: boolean;
            /** Enables hover styles on row. */
            interactive?: boolean;
            /**
                * Use small, condensed appearance for this element and all child elements.
                * @deprecated
                */
            small?: boolean;
            /** Use an alternate background color on odd rows. */
            striped?: boolean;
    }
    export class HTMLTable extends React.PureComponent<IHTMLTableProps> {
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/hotkeys/hotkeys' {
    import * as React from "react";
    import { AbstractPureComponent, IProps } from "@blueprintjs/core/common";
    export { Hotkey, IHotkeyProps } from "@blueprintjs/core/components/hotkeys/hotkey";
    export { KeyCombo, IKeyComboProps } from "@blueprintjs/core/components/hotkeys/keyCombo";
    export { HotkeysTarget, IHotkeysTargetComponent } from "@blueprintjs/core/components/hotkeys/hotkeysTarget";
    export { IKeyCombo, comboMatches, getKeyCombo, getKeyComboString, parseKeyCombo } from "@blueprintjs/core/components/hotkeys/hotkeyParser";
    export { IHotkeysDialogProps, hideHotkeysDialog, setHotkeysDialogProps } from "@blueprintjs/core/components/hotkeys/hotkeysDialog";
    export interface IHotkeysProps extends IProps {
        /**
          * In order to make local hotkeys work on elements that are not normally
          * focusable, such as `<div>`s or `<span>`s, we add a `tabIndex` attribute
          * to the hotkey target, which makes it focusable. By default, we use `0`,
          * but you can override this value to change the tab navigation behavior
          * of the component. You may even set this value to `null`, which will omit
          * the `tabIndex` from the component decorated by `HotkeysTarget`.
          */
        tabIndex?: number;
    }
    export class Hotkeys extends AbstractPureComponent<IHotkeysProps, {}> {
        static displayName: string;
        static defaultProps: {
            tabIndex: number;
        };
        render(): JSX.Element;
        protected validateProps(props: IHotkeysProps & {
            children: React.ReactNode;
        }): void;
    }
}

declare module '@blueprintjs/core/components/icon/icon' {
    import * as React from "react";
    import { IconName } from "@blueprintjs/icons";
    import { IIntentProps, IProps, MaybeElement } from "@blueprintjs/core/common";
    export { IconName };
    export interface IIconProps extends IIntentProps, IProps {
            /** This component does not support custom children. Use the `icon` prop. */
            children?: never;
            /**
                * Color of icon. This is used as the `fill` attribute on the `<svg>` image
                * so it will override any CSS `color` property, including that set by
                * `intent`. If this prop is omitted, icon color is inherited from
                * surrounding text.
                */
            color?: string;
            /**
                * String for the `title` attribute on the rendered element, which will appear
                * on hover as a native browser tooltip.
                */
            htmlTitle?: string;
            /**
                * Name of a Blueprint UI icon, or an icon element, to render. This prop is
                * required because it determines the content of the component, but it can
                * be explicitly set to falsy values to render nothing.
                *
                * - If `null` or `undefined` or `false`, this component will render
                *   nothing.
                * - If given an `IconName` (a string literal union of all icon names), that
                *   icon will be rendered as an `<svg>` with `<path>` tags. Unknown strings
                *   will render a blank icon to occupy space.
                * - If given a `JSX.Element`, that element will be rendered and _all other
                *   props on this component are ignored._ This type is supported to
                *   simplify icon support in other Blueprint components. As a consumer, you
                *   should avoid using `<Icon icon={<Element />}` directly; simply render
                *   `<Element />` instead.
                */
            icon: IconName | MaybeElement;
            /**
                * Size of the icon, in pixels. Blueprint contains 16px and 20px SVG icon
                * images, and chooses the appropriate resolution based on this prop.
                * @default Icon.SIZE_STANDARD = 16
                */
            iconSize?: number;
            /** CSS style properties. */
            style?: React.CSSProperties;
            /**
                * HTML tag to use for the rendered element.
                * @default "span"
                */
            tagName?: keyof JSX.IntrinsicElements;
            /**
                * Description string. This string does not appear in normal browsers, but
                * it increases accessibility. For instance, screen readers will use it for
                * aural feedback. By default, this is set to the icon's name. Pass an
                * explicit falsy value to disable.
                */
            title?: string | false | null;
    }
    export class Icon extends React.PureComponent<IIconProps & React.DOMAttributes<HTMLElement>> {
            static displayName: string;
            static readonly SIZE_STANDARD: number;
            static readonly SIZE_LARGE: number;
            render(): JSX.Element | null;
    }
}

declare module '@blueprintjs/core/components/menu/menu' {
    import * as React from "react";
    import { IProps } from "@blueprintjs/core/common/props";
    import { MenuDivider } from "@blueprintjs/core/components/menu/menuDivider";
    import { MenuItem } from "@blueprintjs/core/components/menu/menuItem";
    export interface IMenuProps extends IProps, React.HTMLAttributes<HTMLUListElement> {
        /** Whether the menu items in this menu should use a large appearance. */
        large?: boolean;
        /** Ref handler that receives the HTML `<ul>` element backing this component. */
        ulRef?: (ref: HTMLUListElement | null) => any;
    }
    export class Menu extends React.Component<IMenuProps, {}> {
        static displayName: string;
        static Divider: typeof MenuDivider;
        static Item: typeof MenuItem;
        render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/menu/menuDivider' {
    import * as React from "react";
    import { IProps } from "@blueprintjs/core/common/props";
    export interface IMenuDividerProps extends IProps {
        /** This component does not support children. */
        children?: never;
        /** Optional header title. */
        title?: React.ReactNode;
    }
    export class MenuDivider extends React.Component<IMenuDividerProps, {}> {
        static displayName: string;
        render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/menu/menuItem' {
    import * as React from "react";
    import { IActionProps, ILinkProps } from "@blueprintjs/core/common/props";
    import { IPopoverProps } from "@blueprintjs/core/components/popover/popover";
    export interface IMenuItemProps extends IActionProps, ILinkProps {
            /** Item text, required for usability. */
            text: React.ReactNode;
            /** Whether this menu item should appear with an active state. */
            active?: boolean;
            /**
                * Children of this component will be rendered in a __submenu__ that appears when hovering or
                * clicking on this menu item.
                *
                * Use `text` prop for the content of the menu item itself.
                */
            children?: React.ReactNode;
            /**
                * Whether this menu item is non-interactive. Enabling this prop will ignore `href`, `tabIndex`,
                * and mouse event handlers (in particular click, down, enter, leave).
                */
            disabled?: boolean;
            /**
                * Right-aligned label text content, useful for displaying hotkeys.
                *
                * This prop actually supports JSX elements, but TypeScript will throw an error because
                * `HTMLAttributes` only allows strings. Use `labelElement` to supply a JSX element in TypeScript.
                */
            label?: string;
            /**
                * A space-delimited list of class names to pass along to the right-aligned label wrapper element.
                */
            labelClassName?: string;
            /**
                * Right-aligned label content, useful for displaying hotkeys.
                */
            labelElement?: React.ReactNode;
            /**
                * Whether the text should be allowed to wrap to multiple lines.
                * If `false`, text will be truncated with an ellipsis when it reaches `max-width`.
                * @default false
                */
            multiline?: boolean;
            /**
                * Props to spread to `Popover`. Note that `content` and `minimal` cannot be
                * changed and `usePortal` defaults to `false` so all submenus will live in
                * the same container.
                */
            popoverProps?: Partial<IPopoverProps>;
            /**
                * Whether an enabled item without a submenu should automatically close its parent popover when clicked.
                * @default true
                */
            shouldDismissPopover?: boolean;
            /**
                * Name of the HTML tag that wraps the MenuItem.
                * @default "a"
                */
            tagName?: keyof JSX.IntrinsicElements;
            /**
                * A space-delimited list of class names to pass along to the text wrapper element.
                */
            textClassName?: string;
    }
    export class MenuItem extends React.PureComponent<IMenuItemProps & React.AnchorHTMLAttributes<HTMLAnchorElement>> {
            static defaultProps: IMenuItemProps;
            static displayName: string;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/navbar/navbar' {
    import * as React from "react";
    import { HTMLDivProps, IProps } from "@blueprintjs/core/common/props";
    import { NavbarDivider } from "@blueprintjs/core/components/navbar/navbarDivider";
    import { NavbarGroup } from "@blueprintjs/core/components/navbar/navbarGroup";
    import { NavbarHeading } from "@blueprintjs/core/components/navbar/navbarHeading";
    export { INavbarDividerProps } from "@blueprintjs/core/components/navbar/navbarDivider";
    export interface INavbarProps extends IProps, HTMLDivProps {
        /**
          * Whether this navbar should be fixed to the top of the viewport (using CSS `position: fixed`).
          */
        fixedToTop?: boolean;
    }
    export class Navbar extends React.PureComponent<INavbarProps, {}> {
        static displayName: string;
        static Divider: typeof NavbarDivider;
        static Group: typeof NavbarGroup;
        static Heading: typeof NavbarHeading;
        render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/navbar/navbarDivider' {
    import * as React from "react";
    import { HTMLDivProps, IProps } from "@blueprintjs/core/common/props";
    export interface INavbarDividerProps extends IProps, HTMLDivProps {
    }
    export class NavbarDivider extends React.PureComponent<INavbarDividerProps, {}> {
        static displayName: string;
        render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/navbar/navbarGroup' {
    import * as React from "react";
    import { Alignment } from "@blueprintjs/core/common/alignment";
    import { HTMLDivProps, IProps } from "@blueprintjs/core/common/props";
    export interface INavbarGroupProps extends IProps, HTMLDivProps {
        /**
          * The side of the navbar on which the group should appear.
          * The `Alignment` enum provides constants for these values.
          * @default Alignment.LEFT
          */
        align?: Alignment;
    }
    export class NavbarGroup extends React.PureComponent<INavbarGroupProps, {}> {
        static displayName: string;
        static defaultProps: INavbarGroupProps;
        render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/navbar/navbarHeading' {
    import * as React from "react";
    import { HTMLDivProps, IProps } from "@blueprintjs/core/common/props";
    export interface INavbarHeadingProps extends IProps, HTMLDivProps {
    }
    export class NavbarHeading extends React.PureComponent<INavbarHeadingProps, {}> {
        static displayName: string;
        render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/non-ideal-state/nonIdealState' {
    import * as React from "react";
    import { IProps, MaybeElement } from "@blueprintjs/core/common/props";
    import { IconName } from "@blueprintjs/core/components/icon/icon";
    export interface INonIdealStateProps extends IProps {
            /** An action to resolve the non-ideal state which appears after `description`. */
            action?: JSX.Element;
            /**
                * Advanced usage: React `children` will appear last (after `action`).
                * Avoid passing raw strings as they will not receive margins and disrupt the layout flow.
                */
            children?: React.ReactNode;
            /**
                * A longer description of the non-ideal state.
                * A string or number value will be wrapped in a `<div>` to preserve margins.
                */
            description?: React.ReactChild;
            /** The name of a Blueprint icon or a JSX Element (such as `<Spinner/>`) to render above the title. */
            icon?: IconName | MaybeElement;
            /** The title of the non-ideal state. */
            title?: React.ReactNode;
    }
    export class NonIdealState extends React.PureComponent<INonIdealStateProps, {}> {
            static displayName: string;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/overflow-list/overflowList' {
    import * as React from "react";
    import { Boundary } from "@blueprintjs/core/common/boundary";
    import { IProps } from "@blueprintjs/core/common/props";
    export interface IOverflowListProps<T> extends IProps {
            /**
                * Which direction the items should collapse from: start or end of the
                * children. This also determines whether `overflowRenderer` appears before
                * (`START`) or after (`END`) the visible items.
                * @default Boundary.START
                */
            collapseFrom?: Boundary;
            /**
                * All items to display in the list. Items that do not fit in the container
                * will be rendered in the overflow instead.
                */
            items: T[];
            /**
                * The minimum number of visible items that should never collapse into the
                * overflow menu, regardless of DOM dimensions.
                * @default 0
                */
            minVisibleItems?: number;
            /**
                * If `true`, all parent DOM elements of the container will also be
                * observed. If changes to a parent's size is detected, the overflow will be
                * recalculated.
                *
                * Only enable this prop if the overflow should be recalculated when a
                * parent element resizes in a way that does not also cause the
                * `OverflowList` to resize.
                * @default false
                */
            observeParents?: boolean;
            /**
                * Callback invoked when the overflowed items change. This is called once
                * after the DOM has settled, rather that on every intermediate change. It
                * is not invoked if resizing produces an unchanged overflow state.
                */
            onOverflow?: (overflowItems: T[]) => void;
            /**
                * Callback invoked to render the overflowed items. Unlike
                * `visibleItemRenderer`, this prop is invoked once with all items that do
                * not fit in the container.
                *
                * Typical use cases for this prop will put overflowed items in a dropdown
                * menu or display a "+X items" label.
                */
            overflowRenderer: (overflowItems: T[]) => React.ReactNode;
            /** CSS properties to apply to the root element. */
            style?: React.CSSProperties;
            /**
                * HTML tag name for the container element.
                * @default "div"
                */
            tagName?: keyof JSX.IntrinsicElements;
            /**
                * Callback invoked to render each visible item.
                * Remember to set a `key` on the rendered element!
                */
            visibleItemRenderer: (item: T, index: number) => React.ReactChild;
    }
    export interface IOverflowListState<T> {
            /** Length of last overflow to dedupe `onOverflow` calls during smooth resizing. */
            lastOverflowCount: number;
            overflow: T[];
            visible: T[];
    }
    export class OverflowList<T> extends React.Component<IOverflowListProps<T>, IOverflowListState<T>> {
            static displayName: string;
            static defaultProps: Partial<IOverflowListProps<any>>;
            static ofType<T>(): new (props: IOverflowListProps<T>) => OverflowList<T>;
            state: IOverflowListState<T>;
            componentDidMount(): void;
            componentWillReceiveProps(nextProps: IOverflowListProps<T>): void;
            shouldComponentUpdate(_nextProps: IOverflowListProps<T>, nextState: IOverflowListState<T>): boolean;
            componentDidUpdate(_prevProps: IOverflowListProps<T>, prevState: IOverflowListState<T>): void;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/overlay/overlay' {
    import * as React from "react";
    import { IProps } from "@blueprintjs/core/common/props";
    export interface IOverlayableProps extends IOverlayLifecycleProps {
            /**
                * Whether the overlay should acquire application focus when it first opens.
                * @default true
                */
            autoFocus?: boolean;
            /**
                * Whether pressing the `esc` key should invoke `onClose`.
                * @default true
                */
            canEscapeKeyClose?: boolean;
            /**
                * Whether the overlay should prevent focus from leaving itself. That is, if the user attempts
                * to focus an element outside the overlay and this prop is enabled, then the overlay will
                * immediately bring focus back to itself. If you are nesting overlay components, either disable
                * this prop on the "outermost" overlays or mark the nested ones `usePortal={false}`.
                * @default true
                */
            enforceFocus?: boolean;
            /**
                * If `true` and `usePortal={true}`, the `Portal` containing the children is created and attached
                * to the DOM when the overlay is opened for the first time; otherwise this happens when the
                * component mounts. Lazy mounting provides noticeable performance improvements if you have lots
                * of overlays at once, such as on each row of a table.
                * @default true
                */
            lazy?: boolean;
            /**
                * Indicates how long (in milliseconds) the overlay's enter/leave transition takes.
                * This is used by React `CSSTransition` to know when a transition completes and must match
                * the duration of the animation in CSS. Only set this prop if you override Blueprint's default
                * transitions with new transitions of a different length.
                * @default 300
                */
            transitionDuration?: number;
            /**
                * Whether the overlay should be wrapped in a `Portal`, which renders its contents in a new
                * element attached to `portalContainer` prop.
                *
                * This prop essentially determines which element is covered by the backdrop: if `false`,
                * then only its parent is covered; otherwise, the entire page is covered (because the parent
                * of the `Portal` is the `<body>` itself).
                *
                * Set this prop to `false` on nested overlays (such as `Dialog` or `Popover`) to ensure that they
                * are rendered above their parents.
                * @default true
                */
            usePortal?: boolean;
            /**
                * Space-delimited string of class names applied to the `Portal` element if
                * `usePortal={true}`.
                */
            portalClassName?: string;
            /**
                * The container element into which the overlay renders its contents, when `usePortal` is `true`.
                * This prop is ignored if `usePortal` is `false`.
                * @default document.body
                */
            portalContainer?: HTMLElement;
            /**
                * A callback that is invoked when user interaction causes the overlay to close, such as
                * clicking on the overlay or pressing the `esc` key (if enabled).
                *
                * Receives the event from the user's interaction, if there was an event (generally either a
                * mouse or key event). Note that, since this component is controlled by the `isOpen` prop, it
                * will not actually close itself until that prop becomes `false`.
                */
            onClose?: (event?: React.SyntheticEvent<HTMLElement>) => void;
    }
    export interface IOverlayLifecycleProps {
            /**
                * Lifecycle method invoked just before the CSS _close_ transition begins on
                * a child. Receives the DOM element of the child being closed.
                */
            onClosing?: (node: HTMLElement) => void;
            /**
                * Lifecycle method invoked just after the CSS _close_ transition ends but
                * before the child has been removed from the DOM. Receives the DOM element
                * of the child being closed.
                */
            onClosed?: (node: HTMLElement) => void;
            /**
                * Lifecycle method invoked just after mounting the child in the DOM but
                * just before the CSS _open_ transition begins. Receives the DOM element of
                * the child being opened.
                */
            onOpening?: (node: HTMLElement) => void;
            /**
                * Lifecycle method invoked just after the CSS _open_ transition ends.
                * Receives the DOM element of the child being opened.
                */
            onOpened?: (node: HTMLElement) => void;
    }
    export interface IBackdropProps {
            /** CSS class names to apply to backdrop element. */
            backdropClassName?: string;
            /** HTML props for the backdrop element. */
            backdropProps?: React.HTMLProps<HTMLDivElement>;
            /**
                * Whether clicking outside the overlay element (either on backdrop when present or on document)
                * should invoke `onClose`.
                * @default true
                */
            canOutsideClickClose?: boolean;
            /**
                * Whether a container-spanning backdrop element should be rendered behind the contents.
                * @default true
                */
            hasBackdrop?: boolean;
    }
    export interface IOverlayProps extends IOverlayableProps, IBackdropProps, IProps {
            /**
                * Toggles the visibility of the overlay and its children.
                * This prop is required because the component is controlled.
                */
            isOpen: boolean;
            /**
                * Name of the transition for internal `CSSTransition`.
                * Providing your own name here will require defining new CSS transition properties.
                * @default Classes.OVERLAY
                */
            transitionName?: string;
    }
    export interface IOverlayState {
            hasEverOpened?: boolean;
    }
    export class Overlay extends React.PureComponent<IOverlayProps, IOverlayState> {
            static displayName: string;
            static defaultProps: IOverlayProps;
            containerElement: HTMLElement;
            constructor(props?: IOverlayProps, context?: any);
            render(): JSX.Element;
            componentDidMount(): void;
            componentWillReceiveProps(nextProps: IOverlayProps): void;
            componentDidUpdate(prevProps: IOverlayProps): void;
            componentWillUnmount(): void;
    }
}

declare module '@blueprintjs/core/components/text/text' {
    import * as React from "react";
    import { IProps } from "@blueprintjs/core/common/props";
    export interface ITextProps extends IProps {
            /**
                * Indicates that this component should be truncated with an ellipsis if it overflows its container.
                * The `title` attribute will also be added when content overflows to show the full text of the children on hover.
                * @default false
                */
            ellipsize?: boolean;
            /**
                * HTML tag name to use for rendered element.
                * @default "div"
                */
            tagName?: keyof JSX.IntrinsicElements;
    }
    export interface ITextState {
            textContent: string;
            isContentOverflowing: boolean;
    }
    export class Text extends React.PureComponent<ITextProps, ITextState> {
            static displayName: string;
            state: ITextState;
            componentDidMount(): void;
            componentDidUpdate(): void;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/panel-stack/panelProps' {
    import * as React from "react";
    /**
        * An object describing a panel in a `PanelStack`.
        */
    export interface IPanel<P = {}> {
            /**
                * The component type to render for this panel. This must be a reference to
                * the component class or SFC, _not_ a JSX element, so it can be re-created
                * dynamically when needed.
                */
            component: React.ComponentType<P & IPanelProps>;
            /**
                * The props passed to the component type when it is rendered. The methods
                * in `IPanelProps` will be injected by `PanelStack`.
                */
            props?: P;
            /**
                * The title to be displayed above this panel. It is also used as the text
                * of the back button for any panel opened by this panel.
                */
            title?: React.ReactNode;
    }
    /**
        * Include this interface in your panel component's props type to access these
        * two functions which are injected by `PanelStack`.
        *
        * ```tsx
        * import { IPanelProps } from "@blueprintjs/core";
        * export class SettingsPanel extends React.Component<IPanelProps & ISettingsPanelProps> {...}
        * ```
        */
    export interface IPanelProps {
            /**
                * Call this method to programatically close this panel. If this is the only
                * panel on the stack then this method will do nothing.
                *
                * Remember that the panel header always contains a "back" button that
                * closes this panel on click (unless there is only one panel on the stack).
                */
            closePanel(): void;
            /**
                * Call this method to open a new panel on the top of the stack.
                */
            openPanel<P>(panel: IPanel<P>): void;
    }
}

declare module '@blueprintjs/core/components/panel-stack/panelStack' {
    import * as React from "react";
    import { IProps } from "@blueprintjs/core/common/props";
    import { IPanel } from "@blueprintjs/core/components/panel-stack/panelProps";
    export interface IPanelStackProps extends IProps {
            /**
                * The initial panel to show on mount. This panel cannot be removed from the
                * stack and will appear when the stack is empty.
                */
            initialPanel: IPanel<any>;
            /**
                * Callback invoked when the user presses the back button or a panel invokes
                * the `closePanel()` injected prop method.
                */
            onClose?: (removedPanel: IPanel) => void;
            /**
                * Callback invoked when a panel invokes the `openPanel(panel)` injected
                * prop method.
                */
            onOpen?: (addedPanel: IPanel) => void;
    }
    export interface IPanelStackState {
            /** Whether the stack is currently animating the push or pop of a panel. */
            direction: "push" | "pop";
            /** The current stack of panels. The first panel in the stack will be displayed. */
            stack: IPanel[];
    }
    export class PanelStack extends React.PureComponent<IPanelStackProps, IPanelStackState> {
            state: IPanelStackState;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/popover/popover' {
    import * as React from "react";
    import { AbstractPureComponent } from "@blueprintjs/core/common/abstractPureComponent";
    import { IPopoverSharedProps } from "@blueprintjs/core/components/popover/popoverSharedProps";
    export const PopoverInteractionKind: {
            CLICK: "click";
            CLICK_TARGET_ONLY: "click-target";
            HOVER: "hover";
            HOVER_TARGET_ONLY: "hover-target";
    };
    export type PopoverInteractionKind = typeof PopoverInteractionKind[keyof typeof PopoverInteractionKind];
    export interface IPopoverProps extends IPopoverSharedProps {
            /** HTML props for the backdrop element. Can be combined with `backdropClassName`. */
            backdropProps?: React.HTMLProps<HTMLDivElement>;
            /**
                * The content displayed inside the popover. This can instead be provided as
                * the _second_ element in `children` (first is `target`).
                */
            content?: string | JSX.Element;
            /**
                * The kind of interaction that triggers the display of the popover.
                * @default PopoverInteractionKind.CLICK
                */
            interactionKind?: PopoverInteractionKind;
            /**
                * Enables an invisible overlay beneath the popover that captures clicks and
                * prevents interaction with the rest of the document until the popover is
                * closed. This prop is only available when `interactionKind` is
                * `PopoverInteractionKind.CLICK`. When popovers with backdrop are opened,
                * they become focused.
                * @default false
                */
            hasBackdrop?: boolean;
            /**
                * Whether to apply minimal styles to this popover, which includes removing
                * the arrow and adding `Classes.MINIMAL` to minimize and accelerate the
                * transitions.
                * @default false
                */
            minimal?: boolean;
            /**
                * Ref supplied to the `Classes.POPOVER` element.
                */
            popoverRef?: (ref: HTMLDivElement | null) => void;
            /**
                * The target to which the popover content is attached. This can instead be
                * provided as the _first_ element in `children`.
                */
            target?: string | JSX.Element;
    }
    export interface IPopoverState {
            transformOrigin: string;
            isOpen: boolean;
            hasDarkParent: boolean;
    }
    export class Popover extends AbstractPureComponent<IPopoverProps, IPopoverState> {
            static displayName: string;
            static defaultProps: IPopoverProps;
            /**
                * DOM element that contains the popover.
                * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,
                * so this reference can be very useful for testing.
                */
            popoverElement: HTMLElement;
            /** DOM element that contains the target. */
            targetElement: HTMLElement;
            state: IPopoverState;
            render(): JSX.Element;
            componentDidMount(): void;
            componentWillReceiveProps(nextProps: IPopoverProps): void;
            componentDidUpdate(): void;
            /**
                * Instance method to instruct the `Popover` to recompute its position.
                *
                * This method should only be used if you are updating the target in a way
                * that does not cause it to re-render, such as changing its _position_
                * without changing its _size_ (since `Popover` already repositions when it
                * detects a resize).
                */
            reposition: () => void;
            protected validateProps(props: IPopoverProps & {
                    children?: React.ReactNode;
            }): void;
    }
}

declare module '@blueprintjs/core/components/popover/popoverSharedProps' {
    import { Boundary as PopperBoundary, Modifiers as PopperModifiers } from "popper.js";
    import { IProps } from "@blueprintjs/core/common/props";
    import { IOverlayableProps } from "@blueprintjs/core/components/overlay/overlay";
    export { PopperBoundary, PopperModifiers };
    /** `Position` with `"auto"` values, used by `Popover` and `Tooltip`. */
    export const PopoverPosition: {
            AUTO: "auto";
            AUTO_END: "auto-end";
            AUTO_START: "auto-start";
            BOTTOM: "bottom";
            BOTTOM_LEFT: "bottom-left";
            BOTTOM_RIGHT: "bottom-right";
            LEFT: "left";
            LEFT_BOTTOM: "left-bottom";
            LEFT_TOP: "left-top";
            RIGHT: "right";
            RIGHT_BOTTOM: "right-bottom";
            RIGHT_TOP: "right-top";
            TOP: "top";
            TOP_LEFT: "top-left";
            TOP_RIGHT: "top-right";
    };
    export type PopoverPosition = typeof PopoverPosition[keyof typeof PopoverPosition];
    /** Props shared between `Popover` and `Tooltip`. */
    export interface IPopoverSharedProps extends IOverlayableProps, IProps {
            /**
                * Determines the boundary element used by Popper for its `flip` and
                * `preventOverflow` modifiers. Three shorthand keywords are supported;
                * Popper will find the correct DOM element itself.
                * @default "scrollParent"
                */
            boundary?: PopperBoundary;
            /**
                * When enabled, `preventDefault()` is invoked on `click` events that close
                * this popover, which will prevent those clicks from closing outer
                * popovers. When disabled, clicking inside a `Classes.POPOVER_DISMISS`
                * element will close the parent popover.
                *
                * See http://blueprintjs.com/docs/#core/components/popover.closing-on-click
                * @default false
                */
            captureDismiss?: boolean;
            /**
                * Initial opened state when uncontrolled.
                * @default false
                */
            defaultIsOpen?: boolean;
            /**
                * Prevents the popover from appearing when `true`.
                * @default false
                */
            disabled?: boolean;
            /**
                * The amount of time in milliseconds the popover should remain open after
                * the user hovers off the trigger. The timer is canceled if the user mouses
                * over the target before it expires.
                * @default 300
                */
            hoverCloseDelay?: number;
            /**
                * The amount of time in milliseconds the popover should wait before opening
                * after the user hovers over the trigger. The timer is canceled if the user
                * mouses away from the target before it expires.
                * @default 150
                */
            hoverOpenDelay?: number;
            /**
                * Whether a popover that uses a `Portal` should automatically inherit the
                * dark theme from its parent.
                * @default true
                */
            inheritDarkTheme?: boolean;
            /**
                * Whether the popover is visible. Passing this prop puts the popover in
                * controlled mode, where the only way to change visibility is by updating
                * this property. If `disabled={true}`, this prop will be ignored, and the
                * popover will remain closed.
                * @default undefined
                */
            isOpen?: boolean;
            /**
                * Popper modifier options, passed directly to internal Popper instance. See
                * https://popper.js.org/popper-documentation.html#modifiers for complete
                * details.
                */
            modifiers?: PopperModifiers;
            /**
                * Callback invoked in controlled mode when the popover open state *would*
                * change due to user interaction.
                */
            onInteraction?: (nextOpenState: boolean, e?: React.SyntheticEvent<HTMLElement>) => void;
            /**
                * Whether the popover should open when its target is focused. If `true`,
                * target will render with `tabindex="0"` to make it focusable via keyboard
                * navigation.
                * @default true
                */
            openOnTargetFocus?: boolean;
            /**
                * A space-delimited string of class names applied to the popover element.
                */
            popoverClassName?: string;
            /**
                * The position (relative to the target) at which the popover should appear.
                *
                * The default value of `"auto"` will choose the best position when opened
                * and will allow the popover to reposition itself to remain onscreen as the
                * user scrolls around.
                * @default "auto"
                */
            position?: PopoverPosition;
            /**
                * Space-delimited string of class names applied to the target element.
                */
            targetClassName?: string;
            /**
                * HTML props to spread to target element. Use `targetTagName` to change
                * the type of element rendered. Note that `ref` is not supported.
                */
            targetProps?: React.HTMLAttributes<HTMLElement>;
            /**
                * HTML tag name for the target element. This must be an HTML element to
                * ensure that it supports the necessary DOM event handlers.
                *
                * By default, a `<span>` tag is used so popovers appear as inline-block
                * elements and can be nested in text. Use `<div>` tag for a block element.
                * @default "span"
                */
            targetTagName?: keyof JSX.IntrinsicElements;
            /**
                * Whether the popover should be rendered inside a `Portal` attached to
                * `portalContainer` prop.
                *
                * Rendering content inside a `Portal` allows the popover content to escape
                * the physical bounds of its parent while still being positioned correctly
                * relative to its target. Using a `Portal` is necessary if any ancestor of
                * the target hides overflow or uses very complex positioning.
                *
                * Not using a `Portal` can result in smoother performance when scrolling
                * and allows the popover content to inherit CSS styles from surrounding
                * elements, but it remains subject to the overflow bounds of its ancestors.
                * @default true
                */
            usePortal?: boolean;
            /**
                * HTML tag name for the wrapper element, which also receives the
                * `className` prop.
                * @default "span"
                */
            wrapperTagName?: keyof JSX.IntrinsicElements;
    }
}

declare module '@blueprintjs/core/components/portal/portal' {
    import { ValidationMap } from "prop-types";
    import * as React from "react";
    import { IProps } from "@blueprintjs/core/common/props";
    export interface IPortalProps extends IProps {
            /**
                * Callback invoked when the children of this `Portal` have been added to the DOM.
                */
            onChildrenMount?: () => void;
            /**
                * The HTML element that children will be mounted to.
                * @default document.body
                */
            container?: HTMLElement;
    }
    export interface IPortalState {
            hasMounted: boolean;
    }
    export interface IPortalContext {
            /** Additional CSS classes to add to all `Portal` elements in this React context. */
            blueprintPortalClassName?: string;
    }
    /**
        * This component detaches its contents and re-attaches them to document.body.
        * Use it when you need to circumvent DOM z-stacking (for dialogs, popovers, etc.).
        * Any class names passed to this element will be propagated to the new container element on document.body.
        */
    export class Portal extends React.Component<IPortalProps, IPortalState> {
            static displayName: string;
            static contextTypes: ValidationMap<IPortalContext>;
            static defaultProps: IPortalProps;
            context: IPortalContext;
            state: IPortalState;
            render(): React.ReactPortal;
            componentDidMount(): void;
            componentDidUpdate(prevProps: IPortalProps): void;
            componentWillUnmount(): void;
    }
}

declare module '@blueprintjs/core/components/progress-bar/progressBar' {
    import * as React from "react";
    import { IIntentProps, IProps } from "@blueprintjs/core/common/props";
    export interface IProgressBarProps extends IProps, IIntentProps {
            /**
                * Whether the background should animate.
                * @default true
                */
            animate?: boolean;
            /**
                * Whether the background should be striped.
                * @default true
                */
            stripes?: boolean;
            /**
                * A value between 0 and 1 (inclusive) representing how far along the operation is.
                * Values below 0 or above 1 will be interpreted as 0 or 1, respectively.
                * Omitting this prop will result in an "indeterminate" progress meter that fills the entire bar.
                */
            value?: number;
    }
    export class ProgressBar extends React.PureComponent<IProgressBarProps, {}> {
            static displayName: string;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/resize-sensor/resizeSensor' {
    import * as React from "react";
    /** A parallel type to `ResizeObserverEntry` (from resize-observer-polyfill). */
    export interface IResizeEntry {
            /** Measured dimensions of the target. */
            contentRect: DOMRectReadOnly;
            /** The resized element. */
            target: Element;
    }
    /** `ResizeSensor` requires a single DOM element child and will error otherwise. */
    export interface IResizeSensorProps {
            /**
                * Callback invoked when the wrapped element resizes.
                *
                * The `entries` array contains an entry for each observed element. In the
                * default case (no `observeParents`), the array will contain only one
                * element: the single child of the `ResizeSensor`.
                *
                * Note that this method is called _asynchronously_ after a resize is
                * detected and typically it will be called no more than once per frame.
                */
            onResize: (entries: IResizeEntry[]) => void;
            /**
                * If `true`, all parent DOM elements of the container will also be
                * observed for size changes. The array of entries passed to `onResize`
                * will now contain an entry for each parent element up to the root of the
                * document.
                *
                * Only enable this prop if a parent element resizes in a way that does
                * not also cause the child element to resize.
                * @default false
                */
            observeParents?: boolean;
    }
    export class ResizeSensor extends React.PureComponent<IResizeSensorProps> {
            static displayName: string;
            render(): React.ReactElement<any>;
            componentDidMount(): void;
            componentDidUpdate(prevProps: IResizeSensorProps): void;
            componentWillUnmount(): void;
    }
}

declare module '@blueprintjs/core/components/slider/handleProps' {
    import { Intent, IProps } from "@blueprintjs/core/common";
    export const HandleType: {
            FULL: "full";
            START: "start";
            END: "end";
    };
    export type HandleType = typeof HandleType[keyof typeof HandleType];
    export const HandleInteractionKind: {
            LOCK: "lock";
            PUSH: "push";
            NONE: "none";
    };
    export type HandleInteractionKind = typeof HandleInteractionKind[keyof typeof HandleInteractionKind];
    export interface IHandleProps extends IProps {
            /** Numeric value of this handle. */
            value: number;
            /** Intent for the track segment immediately after this handle, taking priority over `intentBefore`. */
            intentAfter?: Intent;
            /** Intent for the track segment immediately before this handle. */
            intentBefore?: Intent;
            /**
                * How this handle interacts with other handles.
                * @default "lock"
                */
            interactionKind?: HandleInteractionKind;
            /**
                * Callback invoked when this handle's value is changed due to a drag
                * interaction. Note that "push" interactions can cause multiple handles to
                * update at the same time.
                */
            onChange?: (newValue: number) => void;
            /** Callback invoked when this handle is released (the end of a drag interaction). */
            onRelease?: (newValue: number) => void;
            /**
                * Handle appearance type.
                * @default "full"
                */
            type?: HandleType;
    }
}

declare module '@blueprintjs/core/components/slider/multiSlider' {
    import * as React from "react";
    import { Intent } from "@blueprintjs/core/common";
    import { AbstractPureComponent } from "@blueprintjs/core/common/abstractPureComponent";
    import { IProps } from "@blueprintjs/core/common/props";
    import { IHandleProps } from "@blueprintjs/core/components/slider/handleProps";
    /** A convenience type for React's optional children prop. */
    export interface IChildrenProps {
            children?: React.ReactNode;
    }
    export interface ISliderBaseProps extends IProps {
            /**
                * Whether the slider is non-interactive.
                * @default false
                */
            disabled?: boolean;
            /**
                * Increment between successive labels. Must be greater than zero.
                * @default 1
                */
            labelStepSize?: number;
            /**
                * Number of decimal places to use when rendering label value. Default value is the number of
                * decimals used in the `stepSize` prop. This prop has _no effect_ if you supply a custom
                * `labelRenderer` callback.
                * @default inferred from stepSize
                */
            labelPrecision?: number;
            /**
                * Maximum value of the slider.
                * @default 10
                */
            max?: number;
            /**
                * Minimum value of the slider.
                * @default 0
                */
            min?: number;
            /**
                * Whether a solid bar should be rendered on the track between current and initial values,
                * or between handles for `RangeSlider`.
                * @default true
                */
            showTrackFill?: boolean;
            /**
                * Increment between successive values; amount by which the handle moves. Must be greater than zero.
                * @default 1
                */
            stepSize?: number;
            /**
                * Callback to render a single label. Useful for formatting numbers as currency or percentages.
                * If `true`, labels will use number value formatted to `labelPrecision` decimal places.
                * If `false`, labels will not be shown.
                * @default true
                */
            labelRenderer?: boolean | ((value: number) => string | JSX.Element);
            /**
                * Whether to show the slider in a vertical orientation.
                * @default false
                */
            vertical?: boolean;
    }
    export interface IMultiSliderProps extends ISliderBaseProps {
            /** Default intent of a track segment, used only if no handle specifies `intentBefore/After`. */
            defaultTrackIntent?: Intent;
            /** Callback invoked when a handle value changes. Receives handle values in sorted order. */
            onChange?(values: number[]): void;
            /** Callback invoked when a handle is released. Receives handle values in sorted order. */
            onRelease?(values: number[]): void;
    }
    export interface ISliderState {
            labelPrecision?: number;
            /** the client size, in pixels, of one tick */
            tickSize?: number;
            /** the size of one tick as a ratio of the component's client size */
            tickSizeRatio?: number;
    }
    export class MultiSlider extends AbstractPureComponent<IMultiSliderProps, ISliderState> {
            static defaultSliderProps: ISliderBaseProps;
            static defaultProps: IMultiSliderProps;
            static displayName: string;
            static Handle: React.StatelessComponent<IHandleProps>;
            state: ISliderState;
            render(): JSX.Element;
            componentWillMount(): void;
            componentDidMount(): void;
            componentDidUpdate(): void;
            componentWillReceiveProps(nextProps: IMultiSliderProps & IChildrenProps): void;
            protected validateProps(props: IMultiSliderProps & IChildrenProps): void;
    }
}

declare module '@blueprintjs/core/components/slider/rangeSlider' {
    import { AbstractPureComponent } from "@blueprintjs/core/common/abstractPureComponent";
    import { ISliderBaseProps } from "@blueprintjs/core/components/slider/multiSlider";
    export type NumberRange = [number, number];
    export interface IRangeSliderProps extends ISliderBaseProps {
        /**
          * Range value of slider. Handles will be rendered at each position in the range.
          * @default [0, 10]
          */
        value?: NumberRange;
        /** Callback invoked when the range value changes. */
        onChange?(value: NumberRange): void;
        /** Callback invoked when a handle is released. */
        onRelease?(value: NumberRange): void;
    }
    export class RangeSlider extends AbstractPureComponent<IRangeSliderProps> {
        static defaultProps: IRangeSliderProps;
        static displayName: string;
        render(): JSX.Element;
        protected validateProps(props: IRangeSliderProps): void;
    }
}

declare module '@blueprintjs/core/components/slider/slider' {
    import { AbstractPureComponent } from "@blueprintjs/core/common/abstractPureComponent";
    import { ISliderBaseProps } from "@blueprintjs/core/components/slider/multiSlider";
    export interface ISliderProps extends ISliderBaseProps {
            /**
                * Initial value of the slider. This determines the other end of the
                * track fill: from `initialValue` to `value`.
                * @default 0
                */
            initialValue?: number;
            /**
                * Value of slider.
                * @default 0
                */
            value?: number;
            /** Callback invoked when the value changes. */
            onChange?(value: number): void;
            /** Callback invoked when the handle is released. */
            onRelease?(value: number): void;
    }
    export class Slider extends AbstractPureComponent<ISliderProps> {
            static defaultProps: ISliderProps;
            static displayName: string;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/spinner/spinner' {
    import { AbstractPureComponent } from "@blueprintjs/core/common/abstractPureComponent";
    import { IIntentProps, IProps } from "@blueprintjs/core/common/props";
    export interface ISpinnerProps extends IProps, IIntentProps {
            /**
                * Width and height of the spinner in pixels. The size cannot be less than
                * 10px.
                *
                * Constants are available for common sizes:
                * - `Spinner.SIZE_SMALL = 20px`
                * - `Spinner.SIZE_STANDARD = 50px`
                * - `Spinner.SIZE_LARGE = 100px`
                *
                * @default Spinner.SIZE_STANDARD = 50
                */
            size?: number;
            /**
                * HTML tag for the two wrapper elements. If rendering a `<Spinner>` inside
                * an `<svg>`, change this to an SVG element like `"g"`.
                * @default "div"
                */
            tagName?: keyof JSX.IntrinsicElements;
            /**
                * A value between 0 and 1 (inclusive) representing how far along the operation is.
                * Values below 0 or above 1 will be interpreted as 0 or 1 respectively.
                * Omitting this prop will result in an "indeterminate" spinner where the head spins indefinitely.
                */
            value?: number;
    }
    export class Spinner extends AbstractPureComponent<ISpinnerProps, {}> {
            static displayName: string;
            static readonly SIZE_SMALL: number;
            static readonly SIZE_STANDARD: number;
            static readonly SIZE_LARGE: number;
            componentDidUpdate(prevProps: ISpinnerProps): void;
            render(): JSX.Element;
            protected validateProps({className, size}: ISpinnerProps): void;
    }
}

declare module '@blueprintjs/core/components/tabs/tab' {
    import * as React from "react";
    import { IProps } from "@blueprintjs/core/common/props";
    export type TabId = string | number;
    export interface ITabProps extends IProps {
            /**
                * Content of tab title, rendered in a list above the active panel.
                * Can also be set via the `title` prop.
                */
            children?: React.ReactNode;
            /**
                * Whether the tab is disabled.
                * @default false
                */
            disabled?: boolean;
            /**
                * Unique identifier used to control which tab is selected
                * and to generate ARIA attributes for accessibility.
                */
            id: TabId;
            /**
                * Panel content, rendered by the parent `Tabs` when this tab is active.
                * If omitted, no panel will be rendered for this tab.
                */
            panel?: JSX.Element;
            /**
                * Space-delimited string of class names applied to tab panel container.
                */
            panelClassName?: string;
            /**
                * Content of tab title element, rendered in a list above the active panel.
                * Can also be set via React `children`.
                */
            title?: React.ReactNode;
    }
    export class Tab extends React.PureComponent<ITabProps, {}> {
            static defaultProps: ITabProps;
            static displayName: string;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/tabs/tabs' {
    import * as React from "react";
    import { AbstractPureComponent } from "@blueprintjs/core/common/abstractPureComponent";
    import { IProps } from "@blueprintjs/core/common/props";
    import { Tab, TabId } from "@blueprintjs/core/components/tabs/tab";
    export const Expander: React.SFC<{}>;
    export interface ITabsProps extends IProps {
            /**
                * Whether the selected tab indicator should animate its movement.
                * @default true
                */
            animate?: boolean;
            /**
                * Initial selected tab `id`, for uncontrolled usage.
                * Note that this prop refers only to `<Tab>` children; other types of elements are ignored.
                * @default first tab
                */
            defaultSelectedTabId?: TabId;
            /**
                * Unique identifier for this `Tabs` container. This will be combined with the `id` of each
                * `Tab` child to generate ARIA accessibility attributes. IDs are required and should be
                * unique on the page to support server-side rendering.
                */
            id: TabId;
            /**
                * If set to `true`, the tab titles will display with larger styling.
                * This will apply large styles only to the tabs at this level, not to nested tabs.
                * @default false
                */
            large?: boolean;
            /**
                * Whether inactive tab panels should be removed from the DOM and unmounted in React.
                * This can be a performance enhancement when rendering many complex panels, but requires
                * careful support for unmounting and remounting.
                * @default false
                */
            renderActiveTabPanelOnly?: boolean;
            /**
                * Selected tab `id`, for controlled usage.
                * Providing this prop will put the component in controlled mode.
                * Unknown ids will result in empty selection (no errors).
                */
            selectedTabId?: TabId;
            /**
                * Whether to show tabs stacked vertically on the left side.
                * @default false
                */
            vertical?: boolean;
            /**
                * A callback function that is invoked when a tab in the tab list is clicked.
                */
            onChange?(newTabId: TabId, prevTabId: TabId, event: React.MouseEvent<HTMLElement>): void;
    }
    export interface ITabsState {
            indicatorWrapperStyle?: React.CSSProperties;
            selectedTabId?: TabId;
    }
    export class Tabs extends AbstractPureComponent<ITabsProps, ITabsState> {
            /** Insert a `Tabs.Expander` between any two children to right-align all subsequent children. */
            static Expander: React.StatelessComponent<{}>;
            static Tab: typeof Tab;
            static defaultProps: Partial<ITabsProps>;
            static displayName: string;
            constructor(props?: ITabsProps);
            render(): JSX.Element;
            componentDidMount(): void;
            componentWillReceiveProps({selectedTabId}: ITabsProps): void;
            componentDidUpdate(prevProps: ITabsProps, prevState: ITabsState): void;
    }
}

declare module '@blueprintjs/core/components/tag/tag' {
    import * as React from "react";
    import { IIntentProps, IProps, MaybeElement } from "@blueprintjs/core/common";
    import { IconName } from "@blueprintjs/core/components/icon/icon";
    export interface ITagProps extends IProps, IIntentProps, React.HTMLAttributes<HTMLSpanElement> {
            /**
                * Whether the tag should appear in an active state.
                * @default false
                */
            active?: boolean;
            /**
                * Whether the tag should take up the full width of its container.
                * @default false
                */
            fill?: boolean;
            /** Name of a Blueprint UI icon (or an icon element) to render before the children. */
            icon?: IconName | MaybeElement;
            /**
                * Whether the tag should visually respond to user interactions. If set
                * to `true`, hovering over the tag will change its color and mouse cursor.
                *
                * Recommended when `onClick` is also defined.
                *
                * @default false
                */
            interactive?: boolean;
            /**
                * Whether this tag should use large styles.
                * @default false
                */
            large?: boolean;
            /**
                * Whether this tag should use minimal styles.
                * @default false
                */
            minimal?: boolean;
            /**
                * Whether tag content should be allowed to occupy multiple lines.
                * If false, a single line of text will be truncated with an ellipsis if
                * it overflows. Note that icons will be vertically centered relative to
                * multiline text.
                * @default false
                */
            multiline?: boolean;
            /**
                * Callback invoked when the tag is clicked.
                * Recommended when `interactive` is `true`.
                */
            onClick?: (e: React.MouseEvent<HTMLDivElement>) => void;
            /**
                * Click handler for remove button.
                * The remove button will only be rendered if this prop is defined.
                */
            onRemove?: (e: React.MouseEvent<HTMLButtonElement>, tagProps: ITagProps) => void;
            /** Name of a Blueprint UI icon (or an icon element) to render after the children. */
            rightIcon?: IconName | MaybeElement;
            /**
                * Whether this tag should have rounded ends.
                * @default false
                */
            round?: boolean;
    }
    export class Tag extends React.PureComponent<ITagProps, {}> {
            static displayName: string;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/tag-input/tagInput' {
    import * as React from "react";
    import { AbstractPureComponent } from "@blueprintjs/core/common/abstractPureComponent";
    import { HTMLInputProps, IIntentProps, IProps, MaybeElement } from "@blueprintjs/core/common/props";
    import { IconName } from "@blueprintjs/core/components/icon/icon";
    import { ITagProps } from "@blueprintjs/core/components/tag/tag";
    /**
        * The method in which a `TagInput` value was added.
        * - `"default"` - indicates that a value was added by manual selection.
        * - `"blur"` - indicates that a value was added when the `TagInput` lost focus.
        *   This is only possible when `addOnBlur=true`.
        * - `"paste"` - indicates that a value was added via paste. This is only
        *   possible when `addOnPaste=true`.
        */
    export type TagInputAddMethod = "default" | "blur" | "paste";
    export interface ITagInputProps extends IIntentProps, IProps {
            /**
                * If true, `onAdd` will be invoked when the input loses focus.
                * Otherwise, `onAdd` is only invoked when `enter` is pressed.
                * @default false
                */
            addOnBlur?: boolean;
            /**
                * If true, `onAdd` will be invoked when the user pastes text containing the `separator`
                * into the input. Otherwise, pasted text will remain in the input.
                *
                * __Note:__ For example, if `addOnPaste=true` and `separator="\n"` (new line), then:
                * - Pasting `"hello"` will _not_ invoke `onAdd`
                * - Pasting `"hello\n"` will invoke `onAdd` with `["hello"]`
                * - Pasting `"hello\nworld"` will invoke `onAdd` with `["hello", "world"]`
                *
                * @default true
                */
            addOnPaste?: boolean;
            /**
                * Whether the component is non-interactive.
                * Note that you'll also need to disable the component's `rightElement`,
                * if appropriate.
                * @default false
                */
            disabled?: boolean;
            /** Whether the tag input should take up the full width of its container. */
            fill?: boolean;
            /**
                * React props to pass to the `<input>` element.
                * Note that `ref` and `key` are not supported here; use `inputRef` below.
                */
            inputProps?: HTMLInputProps;
            /** Ref handler for the `<input>` element. */
            inputRef?: (input: HTMLInputElement | null) => void;
            /** Controlled value of the `<input>` element. This is shorthand for `inputProps={{ value }}`. */
            inputValue?: string;
            /** Whether the tag input should use a large size. */
            large?: boolean;
            /** Name of a Blueprint UI icon (or an icon element) to render on the left side of the input. */
            leftIcon?: IconName | MaybeElement;
            /**
                * Callback invoked when new tags are added by the user pressing `enter` on the input.
                * Receives the current value of the input field split by `separator` into an array.
                * New tags are expected to be appended to the list.
                *
                * The input will be cleared after `onAdd` is invoked _unless_ the callback explicitly
                * returns `false`. This is useful if the provided `value` is somehow invalid and should
                * not be added as a tag.
                */
            onAdd?: (values: string[], method: TagInputAddMethod) => boolean | void;
            /**
                * Callback invoked when new tags are added or removed. Receives the updated list of `values`:
                * new tags are appended to the end of the list, removed tags are removed at their index.
                *
                * Like `onAdd`, the input will be cleared after this handler is invoked _unless_ the callback
                * explicitly returns `false`.
                *
                * This callback essentially implements basic `onAdd` and `onRemove` functionality and merges
                * the two handlers into one to simplify controlled usage.
                *
                * **Note about typed usage:** Your handler can declare a subset type of `React.ReactNode[]`,
                * such as `string[]` or `Array<string | JSX.Element>`, to match the type of your `values` array:
                * ```tsx
                * <TagInput
                *     onChange={(values: string[]) => this.setState({ values })}
                *     values={["apple", "banana", "cherry"]}
                * />
                * ```
                */
            onChange?: (values: React.ReactNode[]) => boolean | void;
            /**
                * Callback invoked when the value of `<input>` element is changed.
                * This is shorthand for `inputProps={{ onChange }}`.
                */
            onInputChange?: React.FormEventHandler<HTMLInputElement>;
            /**
                * Callback invoked when the user depresses a keyboard key.
                * Receives the event and the index of the active tag (or `undefined` if
                * focused in the input).
                */
            onKeyDown?: (event: React.KeyboardEvent<HTMLElement>, index?: number) => void;
            /**
                * Callback invoked when the user releases a keyboard key.
                * Receives the event and the index of the active tag (or `undefined` if
                * focused in the input).
                */
            onKeyUp?: (event: React.KeyboardEvent<HTMLElement>, index?: number) => void;
            /**
                * Callback invoked when the user clicks the X button on a tag.
                * Receives value and index of removed tag.
                */
            onRemove?: (value: string, index: number) => void;
            /**
                * Input placeholder text which will not appear if `values` contains any items
                * (consistent with default HTML input behavior).
                * Use `inputProps.placeholder` if you want the placeholder text to _always_ appear.
                *
                * If you define both `placeholder` and `inputProps.placeholder`, then the former will appear
                * when `values` is empty and the latter at all other times.
                */
            placeholder?: string;
            /**
                * Element to render on right side of input.
                * For best results, use a small spinner or minimal button (button height will adjust if `TagInput` uses large styles).
                * Other elements will likely require custom styles for correct positioning.
                */
            rightElement?: JSX.Element;
            /**
                * Separator pattern used to split input text into multiple values. Default value splits on commas and newlines.
                * Explicit `false` value disables splitting (note that `onAdd` will still receive an array of length 1).
                * @default /[,\n\r]/
                */
            separator?: string | RegExp | false;
            /**
                * React props to pass to each `Tag`. Provide an object to pass the same props to every tag,
                * or a function to customize props per tag.
                *
                * If you define `onRemove` here then you will have to implement your own tag removal
                * handling as `TagInput`'s own `onRemove` handler will never be invoked.
                */
            tagProps?: ITagProps | ((value: React.ReactNode, index: number) => ITagProps);
            /**
                * Controlled tag values. Each value will be rendered inside a `Tag`, which can be customized
                * using `tagProps`. Therefore, any valid React node can be used as a `TagInput` value; falsy
                * values will not be rendered.
                *
                * __Note about typed usage:__ If you know your `values` will always be of a certain `ReactNode`
                * subtype, such as `string` or `ReactChild`, you can use that type on all your handlers
                * to simplify type logic.
                */
            values: React.ReactNode[];
    }
    export interface ITagInputState {
            activeIndex: number;
            inputValue: string;
            isInputFocused: boolean;
    }
    export class TagInput extends AbstractPureComponent<ITagInputProps, ITagInputState> {
            static displayName: string;
            static defaultProps: Partial<ITagInputProps> & object;
            state: ITagInputState;
            componentWillReceiveProps(nextProps: HTMLInputProps & ITagInputProps): void;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/toast/toast' {
    import * as React from "react";
    import { AbstractPureComponent } from "@blueprintjs/core/common/abstractPureComponent";
    import { IActionProps, IIntentProps, ILinkProps, IProps, MaybeElement } from "@blueprintjs/core/common/props";
    import { IconName } from "@blueprintjs/core/components/icon/icon";
    export interface IToastProps extends IProps, IIntentProps {
            /**
                * Action rendered as a minimal `AnchorButton`. The toast is dismissed automatically when the
                * user clicks the action button. Note that the `intent` prop is ignored (the action button
                * cannot have its own intent color that might conflict with the toast's intent). Omit this
                * prop to omit the action button.
                */
            action?: IActionProps & ILinkProps;
            /** Name of a Blueprint UI icon (or an icon element) to render before the message. */
            icon?: IconName | MaybeElement;
            /** Message to display in the body of the toast. */
            message: React.ReactNode;
            /**
                * Callback invoked when the toast is dismissed, either by the user or by the timeout.
                * The value of the argument indicates whether the toast was closed because the timeout expired.
                */
            onDismiss?: (didTimeoutExpire: boolean) => void;
            /**
                * Milliseconds to wait before automatically dismissing toast.
                * Providing a value less than or equal to 0 will disable the timeout (this is discouraged).
                * @default 5000
                */
            timeout?: number;
    }
    export class Toast extends AbstractPureComponent<IToastProps, {}> {
            static defaultProps: IToastProps;
            static displayName: string;
            render(): JSX.Element;
            componentDidMount(): void;
            componentDidUpdate(prevProps: IToastProps): void;
            componentWillUnmount(): void;
    }
}

declare module '@blueprintjs/core/components/toast/toaster' {
    import { AbstractPureComponent } from "@blueprintjs/core/common/abstractPureComponent";
    import { Position } from "@blueprintjs/core/common/position";
    import { IProps } from "@blueprintjs/core/common/props";
    import { IToastProps } from "@blueprintjs/core/components/toast/toast";
    export type IToastOptions = IToastProps & {
            key?: string;
    };
    export type ToasterPosition = typeof Position.TOP | typeof Position.TOP_LEFT | typeof Position.TOP_RIGHT | typeof Position.BOTTOM | typeof Position.BOTTOM_LEFT | typeof Position.BOTTOM_RIGHT;
    /** Instance methods available on a `<Toaster>` component instance. */
    export interface IToaster {
            /**
                * Shows a new toast to the user, or updates an existing toast corresponding to the provided key (optional).
                *
                * Returns the unique key of the toast.
                */
            show(props: IToastProps, key?: string): string;
            /** Dismiss the given toast instantly. */
            dismiss(key: string): void;
            /** Dismiss all toasts instantly. */
            clear(): void;
            /** Returns the props for all current toasts. */
            getToasts(): IToastOptions[];
    }
    /**
        * Props supported by the `<Toaster>` component.
        * These props can be passed as an argument to the static `Toaster.create(props?, container?)` method.
        */
    export interface IToasterProps extends IProps {
            /**
                * Whether a toast should acquire application focus when it first opens.
                * This is disabled by default so that toasts do not interrupt the user's flow.
                * Note that `enforceFocus` is always disabled for `Toaster`s.
                * @default false
                */
            autoFocus?: boolean;
            /**
                * Whether pressing the `esc` key should clear all active toasts.
                * @default true
                */
            canEscapeKeyClear?: boolean;
            /**
                * Whether the toaster should be rendered into a new element attached to `document.body`.
                * If `false`, then positioning will be relative to the parent element.
                *
                * This prop is ignored by `Toaster.create()` as that method always appends a new element
                * to the container.
                * @default true
                */
            usePortal?: boolean;
            /**
                * Position of `Toaster` within its container.
                *
                * Note that only `TOP` and `BOTTOM` are supported because Toaster only
                * supports the top and bottom edge positioning.
                * @default Position.TOP
                */
            position?: ToasterPosition;
    }
    export interface IToasterState {
            toasts: IToastOptions[];
    }
    export class Toaster extends AbstractPureComponent<IToasterProps, IToasterState> implements IToaster {
            static displayName: string;
            static defaultProps: IToasterProps;
            /**
                * Create a new `Toaster` instance that can be shared around your application.
                * The `Toaster` will be rendered into a new element appended to the given container.
                */
            static create(props?: IToasterProps, container?: HTMLElement): IToaster;
            state: {
                    toasts: IToastOptions[];
            };
            show(props: IToastProps, key?: string): string;
            dismiss(key: string, timeoutExpired?: boolean): void;
            clear(): void;
            getToasts(): IToastOptions[];
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/tooltip/tooltip' {
    import * as React from "react";
    import { IIntentProps } from "@blueprintjs/core/common/props";
    import { PopoverInteractionKind } from "@blueprintjs/core/components/popover/popover";
    import { IPopoverSharedProps } from "@blueprintjs/core/components/popover/popoverSharedProps";
    export interface ITooltipProps extends IPopoverSharedProps, IIntentProps {
            /**
                * The content that will be displayed inside of the tooltip.
                */
            content: JSX.Element | string;
            /**
                * The amount of time in milliseconds the tooltip should remain open after
                * the user hovers off the trigger. The timer is canceled if the user mouses
                * over the target before it expires.
                * @default 0
                */
            hoverCloseDelay?: number;
            /**
                * The amount of time in milliseconds the tooltip should wait before opening
                * after the user hovers over the trigger. The timer is canceled if the user
                * mouses away from the target before it expires.
                * @default 100
                */
            hoverOpenDelay?: number;
            /**
                * The kind of hover interaction that triggers the display of the tooltip.
                * Tooltips do not support click interactions.
                * @default PopoverInteractionKind.HOVER_TARGET_ONLY
                */
            interactionKind?: typeof PopoverInteractionKind.HOVER | typeof PopoverInteractionKind.HOVER_TARGET_ONLY;
            /**
                * Indicates how long (in milliseconds) the tooltip's appear/disappear
                * transition takes. This is used by React `CSSTransition` to know when a
                * transition completes and must match the duration of the animation in CSS.
                * Only set this prop if you override Blueprint's default transitions with
                * new transitions of a different length.
                * @default 100
                */
            transitionDuration?: number;
    }
    export class Tooltip extends React.PureComponent<ITooltipProps, {}> {
            static displayName: string;
            static defaultProps: Partial<ITooltipProps>;
            render(): JSX.Element;
            reposition(): void;
    }
}

declare module '@blueprintjs/core/components/tree/tree' {
    import * as React from "react";
    import { IProps } from "@blueprintjs/core/common/props";
    import { ITreeNode } from "@blueprintjs/core/components/tree/treeNode";
    export type TreeEventHandler<T = {}> = (node: ITreeNode<T>, nodePath: number[], e: React.MouseEvent<HTMLElement>) => void;
    export interface ITreeProps<T = {}> extends IProps {
            /**
                * The data specifying the contents and appearance of the tree.
                */
            contents: Array<ITreeNode<T>>;
            /**
                * Invoked when a node is clicked anywhere other than the caret for expanding/collapsing the node.
                */
            onNodeClick?: TreeEventHandler<T>;
            /**
                * Invoked when caret of an expanded node is clicked.
                */
            onNodeCollapse?: TreeEventHandler<T>;
            /**
                * Invoked when a node is right-clicked or the context menu button is pressed on a focused node.
                */
            onNodeContextMenu?: TreeEventHandler<T>;
            /**
                * Invoked when a node is double-clicked. Be careful when using this in combination with
                * an `onNodeClick` (single-click) handler, as the way this behaves can vary between browsers.
                * See http://stackoverflow.com/q/5497073/3124288
                */
            onNodeDoubleClick?: TreeEventHandler<T>;
            /**
                * Invoked when the caret of a collapsed node is clicked.
                */
            onNodeExpand?: TreeEventHandler<T>;
            /**
                * Invoked when the mouse is moved over a node.
                */
            onNodeMouseEnter?: TreeEventHandler<T>;
            /**
                * Invoked when the mouse is moved out of a node.
                */
            onNodeMouseLeave?: TreeEventHandler<T>;
    }
    export class Tree<T = {}> extends React.Component<ITreeProps<T>, {}> {
            static displayName: string;
            static ofType<T>(): new (props: ITreeProps<T>) => Tree<T>;
            static nodeFromPath(path: number[], treeNodes: ITreeNode[]): ITreeNode;
            render(): JSX.Element;
            /**
                * Returns the underlying HTML element of the `Tree` node with an id of `nodeId`.
                * This element does not contain the children of the node, only its label and controls.
                * If the node is not currently mounted, `undefined` is returned.
                */
            getNodeContentElement(nodeId: string | number): HTMLElement | undefined;
    }
}

declare module '@blueprintjs/core/components/tree/treeNode' {
    import * as React from "react";
    import { IProps, MaybeElement } from "@blueprintjs/core/common/props";
    import { IconName } from "@blueprintjs/core/components/icon/icon";
    export interface ITreeNode<T = {}> extends IProps {
            /**
                * Child tree nodes of this node.
                */
            childNodes?: Array<ITreeNode<T>>;
            /**
                * Whether this tree node is non-interactive. Enabling this prop will ignore
                * mouse event handlers (in particular click, down, enter, leave).
                */
            disabled?: boolean;
            /**
                * Whether the caret to expand/collapse a node should be shown.
                * If not specified, this will be true if the node has children and false otherwise.
                */
            hasCaret?: boolean;
            /**
                * The name of a Blueprint icon (or an icon element) to render next to the node's label.
                */
            icon?: IconName | MaybeElement;
            /**
                * A unique identifier for the node.
                */
            id: string | number;
            /**
                */
            isExpanded?: boolean;
            /**
                * Whether this node is selected.
                * @default false
                */
            isSelected?: boolean;
            /**
                * The main label for the node.
                */
            label: string | JSX.Element;
            /**
                * A secondary label/component that is displayed at the right side of the node.
                */
            secondaryLabel?: string | MaybeElement;
            /**
                * An optional custom user object to associate with the node.
                * This property can then be used in the `onClick`, `onContextMenu` and `onDoubleClick`
                * event handlers for doing custom logic per node.
                */
            nodeData?: T;
    }
    export interface ITreeNodeProps<T = {}> extends ITreeNode<T> {
            children?: React.ReactNode;
            contentRef?: (node: TreeNode<T>, element: HTMLDivElement | null) => void;
            depth: number;
            key?: string | number;
            onClick?: (node: TreeNode<T>, e: React.MouseEvent<HTMLDivElement>) => void;
            onCollapse?: (node: TreeNode<T>, e: React.MouseEvent<HTMLSpanElement>) => void;
            onContextMenu?: (node: TreeNode<T>, e: React.MouseEvent<HTMLDivElement>) => void;
            onDoubleClick?: (node: TreeNode<T>, e: React.MouseEvent<HTMLDivElement>) => void;
            onExpand?: (node: TreeNode<T>, e: React.MouseEvent<HTMLSpanElement>) => void;
            onMouseEnter?: (node: TreeNode<T>, e: React.MouseEvent<HTMLDivElement>) => void;
            onMouseLeave?: (node: TreeNode<T>, e: React.MouseEvent<HTMLDivElement>) => void;
            path: number[];
    }
    export class TreeNode<T = {}> extends React.Component<ITreeNodeProps<T>, {}> {
            static displayName: string;
            static ofType<T>(): new (props: ITreeNodeProps<T>) => TreeNode<T>;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/common/utils/compareUtils' {
    export interface IKeyWhitelist<T> {
            include: Array<keyof T>;
    }
    export interface IKeyBlacklist<T> {
            exclude: Array<keyof T>;
    }
    /**
        * Returns true if the arrays are equal. Elements will be shallowly compared by
        * default, or they will be compared using the custom `compare` function if one
        * is provided.
        */
    export function arraysEqual(arrA: any[], arrB: any[], compare?: (a: any, b: any) => boolean): boolean;
    /**
        * Shallow comparison between objects. If `keys` is provided, just that subset
        * of keys will be compared; otherwise, all keys will be compared.
        */
    export function shallowCompareKeys<T extends object>(objA: T, objB: T, keys?: IKeyBlacklist<T> | IKeyWhitelist<T>): boolean;
    /**
        * Deep comparison between objects. If `keys` is provided, just that subset of
        * keys will be compared; otherwise, all keys will be compared.
        */
    export function deepCompareKeys(objA: any, objB: any, keys?: string[]): boolean;
    /**
        * Returns a descriptive object for each key whose values are shallowly unequal
        * between two provided objects. Useful for debugging shouldComponentUpdate.
        */
    export function getShallowUnequalKeyValues<T extends object>(objA: T, objB: T, keys?: IKeyBlacklist<T> | IKeyWhitelist<T>): {
            key: never;
            valueA: any;
            valueB: any;
    }[];
    /**
        * Returns a descriptive object for each key whose values are deeply unequal
        * between two provided objects. Useful for debugging shouldComponentUpdate.
        */
    export function getDeepUnequalKeyValues<T extends object>(objA?: T, objB?: T, keys?: Array<keyof T>): {
            key: keyof T;
            valueA: T[keyof T];
            valueB: T[keyof T];
    }[];
}

declare module '@blueprintjs/core/common/utils/safeInvokeMember' {
    /**
        * Safely invoke the member function with no arguments, if the object
        * exists and the given key is indeed a function, and return its value.
        * Otherwise, return `undefined`.
        */
    export function safeInvokeMember<T extends {
            [k in K]?: () => R;
    }, K extends keyof T, R = void>(obj: T | undefined, key: K): R | undefined;
    /**
        * Safely invoke the member function with one argument, if the object
        * exists and the given key is indeed a function, and return its value.
        * Otherwise, return `undefined`.
        *
        * ```js
        * // example usage
        * safeInvokeMember(this.props.inputProps, "onChange", evt);
        * ```
        */
    export function safeInvokeMember<T extends {
            [k in K]?: (a: A) => R;
    }, K extends keyof T, A, R = void>(obj: T | undefined, key: K, arg1: A): R | undefined;
    /**
        * Safely invoke the member function with two arguments, if the object
        * exists and the given key is indeed a function, and return its value.
        * Otherwise, return `undefined`.
        */
    export function safeInvokeMember<T extends {
            [k in K]?: (a: A, b: B) => R;
    }, K extends keyof T, A, B, R = void>(obj: T | undefined, key: K, arg1: A, arg2: B): R | undefined;
    /**
        * Safely invoke the member function with three arguments, if the object
        * exists and the given key is indeed a function, and return its value.
        * Otherwise, return undefined.
        */
    export function safeInvokeMember<T extends {
            [k in K]?: (a: A, b: B, c: C) => R;
    }, K extends keyof T, A, B, C, R = void>(obj: T | undefined, key: K, arg1: A, arg2: B, arg3: C): R | undefined;
}

declare module '@blueprintjs/core/components/button/abstractButton' {
    import * as React from "react";
    import { Alignment } from "@blueprintjs/core/common/alignment";
    import { IActionProps, MaybeElement } from "@blueprintjs/core/common/props";
    import { IconName } from "@blueprintjs/core/components/icon/icon";
    export interface IButtonProps extends IActionProps {
            /**
                * If set to `true`, the button will display in an active state.
                * This is equivalent to setting `className={Classes.ACTIVE}`.
                * @default false
                */
            active?: boolean;
            /**
                * Text alignment within button. By default, icons and text will be centered
                * within the button. Passing `"left"` or `"right"` will align the button
                * text to that side and push `icon` and `rightIcon` to either edge. Passing
                * `"center"` will center the text and icons together.
                * @default Alignment.CENTER
                */
            alignText?: Alignment;
            /** A ref handler that receives the native HTML element backing this component. */
            elementRef?: (ref: HTMLElement | null) => any;
            /** Whether this button should expand to fill its container. */
            fill?: boolean;
            /** Whether this button should use large styles. */
            large?: boolean;
            /**
                * If set to `true`, the button will display a centered loading spinner instead of its contents.
                * The width of the button is not affected by the value of this prop.
                * @default false
                */
            loading?: boolean;
            /** Whether this button should use minimal styles. */
            minimal?: boolean;
            /** Name of a Blueprint UI icon (or an icon element) to render after the text. */
            rightIcon?: IconName | MaybeElement;
            /** Whether this button should use small styles. */
            small?: boolean;
            /**
                * HTML `type` attribute of button. Common values are `"button"` and `"submit"`.
                * Note that this prop has no effect on `AnchorButton`; it only affects `Button`.
                * @default "button"
                */
            type?: string;
    }
    export interface IButtonState {
            isActive: boolean;
    }
    export abstract class AbstractButton<H extends React.HTMLAttributes<any>> extends React.PureComponent<IButtonProps & H, IButtonState> {
            state: {
                    isActive: boolean;
            };
            protected buttonRef: HTMLElement;
            protected refHandlers: {
                    button: (ref: HTMLElement) => void;
            };
            abstract render(): JSX.Element;
            protected getCommonButtonProps(): {
                    className: string;
                    disabled: (IButtonProps & H)["loading"];
                    onClick: (IButtonProps & H)["onClick"];
                    onKeyDown: (e: React.KeyboardEvent<any>) => void;
                    onKeyUp: (e: React.KeyboardEvent<any>) => void;
                    ref: (ref: HTMLElement) => void;
                    tabIndex: (IButtonProps & H)["tabIndex"];
            };
            protected handleKeyDown: (e: React.KeyboardEvent<any>) => void;
            protected handleKeyUp: (e: React.KeyboardEvent<any>) => void;
            protected renderChildren(): React.ReactNode;
    }
}

declare module '@blueprintjs/core/components/hotkeys/hotkey' {
    import { AbstractPureComponent, IProps } from "@blueprintjs/core/common";
    export interface IHotkeyProps extends IProps {
            /**
                * Whether the hotkey should be triggerable when focused in a text input.
                * @default false
                */
            allowInInput?: boolean;
            /**
                * Hotkey combination string, such as "space" or "cmd+n".
                */
            combo: string;
            /**
                * Whether the hotkey cannot be triggered.
                * @default false
                */
            disabled?: boolean;
            /**
                * Human-friendly label for the hotkey.
                */
            label: string;
            /**
                * If `false`, the hotkey is active only when the target is focused. If
                * `true`, the hotkey can be triggered regardless of what component is
                * focused.
                * @default false
                */
            global?: boolean;
            /**
                * Unless the hotkey is global, you must specify a group where the hotkey
                * will be displayed in the hotkeys dialog. This string will be displayed
                * in a header at the start of the group of hotkeys.
                */
            group?: string;
            /**
                * When `true`, invokes `event.preventDefault()` before the respective `onKeyDown` and
                * `onKeyUp` callbacks are invoked. Enabling this can simplify handler implementations.
                * @default false
                */
            preventDefault?: boolean;
            /**
                * When `true`, invokes `event.stopPropagation()` before the respective `onKeyDown` and
                * `onKeyUp` callbacks are invoked. Enabling this can simplify handler implementations.
                * @default false
                */
            stopPropagation?: boolean;
            /**
                * `keydown` event handler.
                */
            onKeyDown?(e: KeyboardEvent): any;
            /**
                * `keyup` event handler.
                */
            onKeyUp?(e: KeyboardEvent): any;
    }
    export class Hotkey extends AbstractPureComponent<IHotkeyProps, {}> {
            static displayName: string;
            static defaultProps: {
                    allowInInput: boolean;
                    disabled: boolean;
                    global: boolean;
                    preventDefault: boolean;
                    stopPropagation: boolean;
            };
            render(): JSX.Element;
            protected validateProps(props: IHotkeyProps): void;
    }
}

declare module '@blueprintjs/core/components/hotkeys/keyCombo' {
    import * as React from "react";
    import { IProps } from "@blueprintjs/core/common";
    export interface IKeyComboProps extends IProps {
            /** The key combo to display, such as `"cmd + s"`. */
            combo: string;
            /**
                * Whether to render in a minimal style.
                * If `false`, each key in the combo will be rendered inside a `<kbd>` tag.
                * If `true`, only the icon or short name of a key will be rendered with no wrapper styles.
                * @default false
                */
            minimal?: boolean;
    }
    export class KeyCombo extends React.Component<IKeyComboProps, {}> {
            static displayName: string;
            render(): JSX.Element;
    }
}

declare module '@blueprintjs/core/components/hotkeys/hotkeysTarget' {
    import * as React from "react";
    import { IConstructor } from "@blueprintjs/core/common/constructor";
    import { IHotkeysProps } from "@blueprintjs/core/components/hotkeys/hotkeys";
    import { HotkeysEvents } from "@blueprintjs/core/components/hotkeys/hotkeysEvents";
    export interface IHotkeysTargetComponent extends React.Component {
            /** Components decorated with the `@HotkeysTarget` decorator must implement React's component `render` function. */
            render(): React.ReactElement<any> | null | undefined;
            /**
                * Components decorated with the `@HotkeysTarget` decorator must implement
                * this method, and it must return a `Hotkeys` React element.
                */
            renderHotkeys(): React.ReactElement<IHotkeysProps>;
    }
    export function HotkeysTarget<T extends IConstructor<IHotkeysTargetComponent>>(WrappedComponent: T): {
            new (...args: any[]): {
                    globalHotkeysEvents?: HotkeysEvents;
                    localHotkeysEvents?: HotkeysEvents;
                    componentWillMount(): void;
                    componentDidMount(): void;
                    componentWillUnmount(): void;
                    render(): React.ReactElement<any>;
                    renderHotkeys(): React.ReactElement<IHotkeysProps>;
                    setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<{}>) => {} | Pick<{}, K>) | Pick<{}, K>, callback?: () => void): void;
                    forceUpdate(callBack?: () => void): void;
                    readonly props: Readonly<{
                            children?: React.ReactNode;
                    }> & Readonly<{}>;
                    state: Readonly<{}>;
                    context: any;
                    refs: {
                            [key: string]: React.ReactInstance;
                    };
                    shouldComponentUpdate?(nextProps: Readonly<{}>, nextState: Readonly<{}>, nextContext: any): boolean;
                    componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
                    getSnapshotBeforeUpdate?(prevProps: Readonly<{}>, prevState: Readonly<{}>): any;
                    componentDidUpdate?(prevProps: Readonly<{}>, prevState: Readonly<{}>, snapshot?: any): void;
                    UNSAFE_componentWillMount?(): void;
                    componentWillReceiveProps?(nextProps: Readonly<{}>, nextContext: any): void;
                    UNSAFE_componentWillReceiveProps?(nextProps: Readonly<{}>, nextContext: any): void;
                    componentWillUpdate?(nextProps: Readonly<{}>, nextState: Readonly<{}>, nextContext: any): void;
                    UNSAFE_componentWillUpdate?(nextProps: Readonly<{}>, nextState: Readonly<{}>, nextContext: any): void;
            };
            displayName: string;
    } & T;
}

declare module '@blueprintjs/core/components/hotkeys/hotkeyParser' {
    export interface IKeyCodeTable {
            [code: number]: string;
    }
    export interface IKeyCodeReverseTable {
            [key: string]: number;
    }
    export interface IKeyMap {
            [key: string]: string;
    }
    export const KeyCodes: IKeyCodeTable;
    export const Modifiers: IKeyCodeTable;
    export const ModifierBitMasks: IKeyCodeReverseTable;
    export const Aliases: IKeyMap;
    export const ShiftKeys: IKeyMap;
    export interface IKeyCombo {
            key?: string;
            modifiers: number;
    }
    export function comboMatches(a: IKeyCombo, b: IKeyCombo): boolean;
    /**
        * Converts a key combo string into a key combo object. Key combos include
        * zero or more modifier keys, such as `shift` or `alt`, and exactly one
        * action key, such as `A`, `enter`, or `left`.
        *
        * For action keys that require a shift, e.g. `@` or `|`, we inlude the
        * necessary `shift` modifier and automatically convert the action key to the
        * unshifted version. For example, `@` is equivalent to `shift+2`.
        */
    export const parseKeyCombo: (combo: string) => IKeyCombo;
    /**
        * Converts a keyboard event into a valid combo prop string
        */
    export const getKeyComboString: (e: KeyboardEvent) => string;
    /**
        * Determines the key combo object from the given keyboard event. Again, a key
        * combo includes zero or more modifiers (represented by a bitmask) and one
        * action key, which we determine from the `e.which` property of the keyboard
        * event.
        */
    export const getKeyCombo: (e: KeyboardEvent) => IKeyCombo;
    /**
        * Splits a key combo string into its constituent key values and looks up
        * aliases, such as `return` -> `enter`.
        *
        * Unlike the parseKeyCombo method, this method does NOT convert shifted
        * action keys. So `"@"` will NOT be converted to `["shift", "2"]`).
        */
    export const normalizeKeyCombo: (combo: string, platformOverride?: string) => string[];
}

declare module '@blueprintjs/core/components/hotkeys/hotkeysDialog' {
    import { IDialogProps } from "@blueprintjs/core/components";
    import { IHotkeyProps } from "@blueprintjs/core/components/hotkeys/hotkey";
    export interface IHotkeysDialogProps extends IDialogProps {
            /**
                * This string displayed as the group name in the hotkeys dialog for all
                * global hotkeys.
                */
            globalHotkeysGroup?: string;
    }
    export function isHotkeysDialogShowing(): boolean;
    export function setHotkeysDialogProps(props: Partial<IHotkeysDialogProps>): void;
    export function showHotkeysDialog(hotkeys: IHotkeyProps[]): void;
    export function hideHotkeysDialog(): void;
    /**
        * Use this function instead of `hideHotkeysDialog` if you need to ensure that all hotkey listeners
        * have time to execute with the dialog in a consistent open state. This can avoid flickering the
        * dialog between open and closedstates as successive listeners fire.
        */
    export function hideHotkeysDialogAfterDelay(): void;
}

declare module '@blueprintjs/core/components/hotkeys/hotkeysEvents' {
    import { ReactNode } from "react";
    import { IHotkeyProps } from "@blueprintjs/core/components/hotkeys/hotkey";
    import { IKeyCombo } from "@blueprintjs/core/components/hotkeys/hotkeyParser";
    import { IHotkeysProps } from "@blueprintjs/core/components/hotkeys/hotkeys";
    export enum HotkeyScope {
        LOCAL = "local",
        GLOBAL = "global",
    }
    export interface IHotkeyAction {
        combo: IKeyCombo;
        props: IHotkeyProps;
    }
    export class HotkeysEvents {
        constructor(scope: HotkeyScope);
        count(): number;
        clear(): void;
        setHotkeys(props: IHotkeysProps & {
            children?: ReactNode;
        }): void;
        handleKeyDown: (e: KeyboardEvent) => void;
        handleKeyUp: (e: KeyboardEvent) => void;
    }
}

